{"version":3,"file":"js/devise-slice-admin.f1d85a92.js","mappings":"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","sources":["webpack://devisephp-interface/./node_modules/decode-uri-component/index.js","webpack://devisephp-interface/./node_modules/filter-obj/index.js","webpack://devisephp-interface/./node_modules/mezr/mezr.js","webpack://devisephp-interface/./node_modules/query-string/index.js","webpack://devisephp-interface/./node_modules/split-on-first/index.js","webpack://devisephp-interface/./node_modules/strict-uri-encode/index.js"],"sourcesContent":["'use strict';\nvar token = '%[a-f0-9]{2}';\nvar singleMatcher = new RegExp(token, 'gi');\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn decodeURIComponent(components.join(''));\n\t} catch (err) {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tvar left = components.slice(0, split);\n\tvar right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch (err) {\n\t\tvar tokens = input.match(singleMatcher);\n\n\t\tfor (var i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher);\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tvar replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD'\n\t};\n\n\tvar match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch (err) {\n\t\t\tvar result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tvar entries = Object.keys(replaceMap);\n\n\tfor (var i = 0; i < entries.length; i++) {\n\t\t// Replace all decoded components\n\t\tvar key = entries[i];\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nmodule.exports = function (encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\tencodedURI = encodedURI.replace(/\\+/g, ' ');\n\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch (err) {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n};\n","'use strict';\nmodule.exports = function (obj, predicate) {\n\tvar ret = {};\n\tvar keys = Object.keys(obj);\n\tvar isArr = Array.isArray(predicate);\n\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar key = keys[i];\n\t\tvar val = obj[key];\n\n\t\tif (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {\n\t\t\tret[key] = val;\n\t\t}\n\t}\n\n\treturn ret;\n};\n","/*!\n * mezr v0.6.2\n * https://github.com/niklasramo/mezr\n * Copyright (c) 2016 Niklas Rämö <inramo@gmail.com>\n * Released under the MIT license\n */\n\n(function (global, factory) {\n\n  if (typeof define === 'function' && define.amd) {\n    define([], function () {\n      return factory(global);\n    });\n  }\n  else if (typeof module === 'object' && module.exports) {\n    module.exports = factory(global);\n  }\n  else {\n    global.mezr = factory(global);\n  }\n\n}(this, function (global, undefined) {\n\n  'use strict';\n\n  // Make sure we received a valid window object from the arguments.\n  var win = global.document && global.self === global.document.defaultView ? global : window;\n\n  // Cache document, root and body elements.\n  var doc = win.document;\n  var root = doc.documentElement;\n  var body = doc.body;\n\n  // Throw error if body is not available\n  if (!body) {\n    throw Error('Mezr needs access to body element.');\n  }\n\n  // Cache some often used native functions.\n  var abs = Math.abs;\n  var max = Math.max;\n  var min = Math.min;\n\n  // String to number mappings for element edges.\n  var edges = {\n    content: 1,\n    padding: 2,\n    scroll: 3,\n    border: 4,\n    margin: 5\n  };\n\n  // CSS display values which make it impossible for an element to have a\n  // scrollbar.\n  var unscrollableDisplayValues = ['inline', 'table-column', 'table-column-group'];\n\n  // Temporary bounding client rect data.\n  var tempBCR;\n\n  // Mezr settings.\n  var settings = {};\n\n  // Default options for place method.\n  settings.placeDefaultOptions = {\n    element: null,\n    target: null,\n    position: 'left top left top',\n    offsetX: 0,\n    offsetY: 0,\n    contain: null,\n    adjust: null\n  };\n\n  // Get the primary supported transform property.\n  settings.transform = getSupportedTransform();\n\n  // Check if transformed elements leak fixed elements? According W3C\n  // specification (about transform rendering) a transformed element should\n  // contain fixed elements, but not every browser follows the spec. So we need\n  // to test it.\n  settings.transformLeaksFixed = doesTransformLeakFixed();\n\n  /**\n   * Public methods\n   * **************\n   */\n\n  /**\n   * Returns the width of an element in pixels. Accepts also the window object\n   * (for getting the viewport width) and the document object (for getting the\n   * document width) in place of element.\n   *\n   * @example\n   * mezr.width(elemA, 'content');\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} [edge='border']\n   * @returns {Number}\n   *   - The return value may be fractional when calculating the width of an\n   *     element. For window and document objects the value is always an integer\n   *     though.\n   */\n  function getWidth(el, edge) {\n\n    edge = edge && edges[edge] || 4;\n\n    return getDimension('width', el, edge > 1, edge > 2, edge > 3, edge > 4);\n\n  }\n\n  /**\n   * Returns the height of an element in pixels. Accepts also the window object\n   * (for getting the viewport height) and the document object (for getting the\n   * document height) in place of element.\n   *\n   * @example\n   * mezr.height(elemA, 'content');\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} [edge='border']\n   * @returns {Number}\n   *   - The return value may be fractional when calculating the width of an\n   *     element. For window and document objects the value is always an integer\n   *     though.\n   */\n  function getHeight(el, edge) {\n\n    edge = edge && edges[edge] || 4;\n\n    return getDimension('height', el, edge > 1, edge > 2, edge > 3, edge > 4);\n\n  }\n\n  /**\n   * Returns the element's offset from another element, window or document. In\n   * practice the offset means the vertical and horizontal distance from the\n   * comparison element's northwest corner to the target element's northwest\n   * corner. By default the comparison element is considered to be the document.\n   *\n   * @example\n   * // Returns offset from document's northwest corner to elemA's content\n   * // layer's northwest corner.\n   * mezr.offset(elemA, 'content');\n   *\n   * @example\n   * // Returns offset from window's northwest corner to elemA's content layer's\n   * // northwest corner.\n   * mezr.offset([elemA, 'content'], window);\n   *\n   * @example\n   * // Returns offset from elemB's margin layer's northwest corner to elemA's\n   * // content layer's northwest corner.\n   * mezr.offset([elemA, 'padding'], [elemB, 'margin']);\n   *\n   * @public\n   * @param {(Array|Document|Element|Rectangle|Window)} el\n   * @param {(Array|Document|Edge|Element|Rectangle|Window)} [edge='border']\n   *   - If this argument is a string it is considered to be an edge layer\n   *     definition for the first argument. Otherwise this is considered to be a\n   *     defintion of an element, document or window.\n   * @returns {Offset}\n   */\n  function getOffset(el, edge) {\n\n    // Use default syntax if the element is not an array and the edge is\n    // undefined or a string.\n    if (!Array.isArray(el) && (!edge || typeof edge === 'string')) {\n      return getOffsetFromDocument(el, edge);\n    }\n\n    // Otherwise assume that two element/document/window defintions were\n    // provided and calculate the offset from the second to the first element.\n    else {\n\n      var elemA = [].concat(el);\n      var elemB = [].concat(edge);\n      var offsetA = isPlainObject(el) ? el : getOffsetFromDocument(elemA[0], elemA[1]);\n      var offsetB = isPlainObject(edge) ? edge : getOffsetFromDocument(elemB[0], elemB[1]);\n\n      return {\n        left: offsetA.left - offsetB.left,\n        top: offsetA.top - offsetB.top\n      };\n\n    }\n\n  }\n\n  /**\n   * Returns an object containing the provided element's dimensions and offsets.\n   * This is basically a helper method for calculating an element's dimensions\n   * and offsets simultaneously. Mimics the native getBoundingClientRect method\n   * with the added bonus of allowing to provide the \"edge\" of the element.\n   *\n   * @example\n   * // Returns rect data for elemA (using the element's \"content\" layer in the\n   * // calculations) with the offset calculated from the document.\n   * mezr.offset(elemA, 'content');\n   *\n   * @example\n   * // Returns rect data for elemA (using the element's \"content\" layer in the\n   * // calculations) with the offset calculated from the window.\n   * mezr.rect([elemA, 'content'], window);\n   *\n   * @example\n   * // Returns rect data for elemA (using the element's \"padding\" layer in the\n   * // calculations) with the offset calculated from the elemB (\"margin\"\n   * // layer).\n   * mezr.rect([elemA, 'padding'], [elemB, 'margin']);\n   *\n   * @public\n   * @param {(Array|Document|Element|Rectangle|Window)} el\n   * @param {(Array|Document|Edge|Element|Rectangle|Window)} [edge='border']\n   *   - If this argument is a string it is considered to be an edge layer\n   *     definition for the first argument. Otherwise this is considered to be a\n   *     defintion of an element, document or window.\n   * @returns {Rectangle}\n   */\n  function getRect(el, edge) {\n\n    // Use default syntax if the element is not an array and the edge is\n    // undefined or a string.\n    if (!Array.isArray(el) && (!edge || typeof edge === 'string')) {\n      return getRectInternal(el, edge);\n    }\n\n    // Otherwise assume that two element/document/window defintions were\n    // provided and calculate the offset from the second to the first element.\n    else {\n\n      var elemA = [].concat(el);\n      var elemB = [].concat(edge);\n      var rect = isPlainObject(el) ? el : getRectInternal(elemA[0], elemA[1]);\n      var offsetFrom = isPlainObject(edge) ? edge : getOffsetFromDocument(elemB[0], elemB[1]);\n\n      rect.left = rect.left - offsetFrom.left;\n      rect.top = rect.top - offsetFrom.top;\n\n      return rect;\n\n    }\n\n  }\n\n  /**\n   * Returns the element's containing block, which is considered to be the\n   * closest ancestor element (or window, or document, or the target element\n   * itself) that the target element's positioning is relative to. In other\n   * words, containing block is the element the target element's CSS properties\n   * \"left\", \"right\", \"top\" and \"bottom\" are relative to. You should not confuse\n   * this with the native elem.offsetParent read-only property, which works in a\n   * similar fashion (and even identically in certain situations), but is really\n   * not the same thing (although the name might imply it).\n   *\n   * The logic:\n   * - Document is considered to be the root containing block of all elements\n   *   and the window. Getting the document's containing block will return null.\n   * - Static element does not have a containing block since setting values to\n   *   the \"left\", \"right\", \"top\" and \"bottom\" CSS properties does not have any\n   *   effect on the element's position. Thus, getting the containing block of a\n   *   static element will return null.\n   * - Relative element's containing block is always the element itself.\n   * - Fixed element's containing block is always the closest transformed\n   *   ancestor or window if the element does not have any transformed\n   *   ancestors. An exception is made for browsers which allow fixed elements\n   *   to bypass the W3C specification of transform rendering. In those browsers\n   *   fixed element's containing block is always the window.\n   * - Absolute element's containing block is the closest ancestor element that\n   *   is transformed or positioned (any element which is not static), or\n   *   document if no positioned or transformed ancestor is not found.\n   * - Sticky element is a special case since \"left\", \"right\", \"top\" and\n   *   \"bottom\" CSS properties do not always affect the element's position.\n   *   However, for consistency, the closest scrolling ancestor element is\n   *   always considered as sticky element's containing block, and if no\n   *   scrolling ancestor is found window is returned.\n   * - Root element and body element are considered as equals with all other\n   *   elements and are treated equally with all other elements.\n   *\n   * @example\n   * mezr.containingBlock(elemA);\n   *\n   * @example\n   * mezr.containingBlock(elemA, 'fixed');\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {String} [fakePosition]\n   *   - An optional argument which allows you to get the element's containing\n   *     block as if the element had this CSS position value applied. Using this\n   *     argument does not modify the element's true CSS position in any way,\n   *     it's only used for the calculations.\n   * @returns {?(Document|Element|Window)}\n   */\n  function getContainingBlock(el, fakePosition) {\n\n    var ret;\n    var scrollProps;\n    var parent;\n    var style;\n    var i;\n\n    // If we have document return null right away.\n    if (el === doc) {\n      return null;\n    }\n\n    // If we have window return document right away.\n    if (el === win) {\n      return doc;\n    }\n\n    // Now that we know we have an element in our hands, let's get it's\n    // position. Get element's current position value if a specific position is\n    // not provided.\n    var position = fakePosition || getStyle(el, 'position');\n\n    // Relative element's container is always the element itself.\n    if (position === 'relative') {\n      return el;\n    }\n\n    // If the element is fixed or absolute positioned.\n    else if (position === 'fixed' || position === 'absolute') {\n\n      // If the element is fixed and transforms leak fixed elements, always\n      // return window.\n      if (position === 'fixed' && settings.transformLeaksFixed) {\n        return win;\n      }\n\n      // Alrighty, so now fetch the element's parent (which is document for the\n      // root) and set it as the initial containing block. Fallback to null if\n      // everything else fails.\n      ret = el === root ? doc : el.parentElement || null;\n\n      // If element is fixed positioned: as long as the containing block is an\n      // element and is not transformed, try to get the element's parent element\n      // and fallback to document.\n      if (position === 'fixed') {\n        while (ret && ret !== doc && !isTransformed(ret)) {\n          ret = ret.parentElement || doc;\n        }\n        return ret === doc ? win : ret;\n      }\n\n      // If the element is absolute positioned: as long as the containing block\n      // is an element, is static and is not transformed, try to get the\n      // element's parent element and fallback to document.\n      else {\n        while (ret && ret !== doc && getStyle(ret, 'position') === 'static' && !isTransformed(ret)) {\n          ret = ret.parentElement || doc;\n        }\n        return ret;\n      }\n\n    }\n\n    // Sticky element's container is always the closest scrolling ancestor or\n    // window.\n    else if (position === 'sticky' || position === '-webkit-sticky') {\n\n      scrollProps = ['overflow', 'overflow-y', 'overflow-x'];\n      parent = el.parentNode;\n      el = null;\n\n      while (!el && parent && parent !== doc) {\n\n        for (i = 0; i < 3; i++) {\n          style = getStyle(parent, scrollProps[i]);\n          if (style === 'auto' || style === 'scroll') {\n            el = parent;\n            break;\n          }\n        }\n\n        if (!el) {\n          parent = parent.parentNode;\n        }\n\n      }\n\n      return el || win;\n\n    }\n\n    // If the element is static or an invalid position is provided always return\n    // null.\n    return null;\n\n  }\n\n  /**\n   * Calculate the distance between two elements or rectangles. Returns a\n   * number. If the elements/rectangles overlap the function returns -1. In\n   * other cases the function returns the distance in pixels (fractional)\n   * between the the two elements/rectangles.\n   *\n   * @example\n   * mezr.distance(elemA, elemB);\n   *\n   * @example\n   * mezr.distance([elemA, 'padding'], [elemB, 'margin']);\n\n   * @example\n   * mezr.distance(elemA, {left: 34, top: 56, width: 100, height: 200});\n   *\n   * @public\n   * @param {(Array|Document|Element|Window|Rectangle)} a\n   * @param {(Array|Document|Element|Window|Rectangle)} b\n   * @returns {Number}\n   */\n  function getDistance(a, b) {\n\n    var aRect = getSanitizedRect(a);\n    var bRect = getSanitizedRect(b);\n\n    return getIntersection(aRect, bRect) ? -1 : getDistanceBetweenRects(aRect, bRect);\n\n  }\n\n  /**\n   * Detect if all of the provided elements overlap and calculate the possible\n   * intersection area's dimensions and offsets. If the intersection area exists\n   * the function returns an object containing the intersection area's\n   * dimensions and offsets. Otherwise null is returned.\n   *\n   * @example\n   * mezr.intersection(elemA, elemB);\n   *\n   * @example\n   * mezr.intersection(elemA, [elemB, 'padding'], {\n   *   left: 0,\n   *   top: 10,\n   *   width: 100,\n   *   height: 200\n   * });\n   *\n   * @public\n   * @param {...(Array|Document|Element|Window|Rectangle)} el\n   * @returns {?Rectangle}\n   */\n  function getIntersectionMultiple() {\n\n    // Get the initial intersection of the first two items.\n    var intersection = getIntersection(arguments[0], arguments[1]);\n\n    // If there are more than two items.\n    if (arguments.length > 2) {\n\n      // Loop the arguments until the end or until the intersection is\n      // non-existent.\n      for (var i = 2; i < arguments.length; ++i) {\n        intersection = getIntersection(intersection, arguments[i]);\n        if (!intersection) {\n          break;\n        }\n      }\n\n    }\n\n    return intersection;\n\n  }\n\n  /**\n   * Calculate how much an element overflows another element per each side.\n   *\n   * @example\n   * mezr.overflow(elemA, elemB);\n   *\n   * @example\n   * mezr.overflow(elemA, [elemB, 'padding']);\n   *\n   * @public\n   * @param {(Array|Document|Element|Window|Rectangle)} elA\n   * @param {(Array|Document|Element|Window|Rectangle)} elB\n   * @returns {Overflow}\n   */\n  function getOverflow(elA, elB) {\n\n    var ret = getOverlap(elB, elA);\n\n    return {\n      left: -ret.left,\n      right: -ret.right,\n      top: -ret.top,\n      bottom: -ret.bottom\n    };\n\n  }\n\n  /**\n   * Calculate an element's position (left/top CSS properties) when positioned\n   * relative to another element, window or the document.\n   *\n   * @example\n   * var newElementPosition = mezr.place({\n   *   element: [elemA, 'content'],\n   *   target: [elemB, 'margin'],\n   *   position: 'left top center center',\n   *   offsetX: -5,\n   *   offsetY: '50%',\n   *   contain: {\n   *     within: [elemC, 'padding'],\n   *     onOverflow: {\n   *       left: 'forcepush',\n   *       right: 'push',\n   *       top: 'none',\n   *       bottom: 'push'\n   *     }\n   *   },\n   *   adjust: function (position, data) {\n   *     position.left -= 1;\n   *     position.top += 1;\n   *   }\n   * });\n   *\n   * @public\n   * @param {PlaceOptions} options\n   * @returns {PlaceData}\n   */\n  function getPlace(options) {\n\n    var ret = {};\n    var opts = mergeObjects([settings.placeDefaultOptions, options || {}]);\n    var position = typeof opts.position === 'string' ? opts.position.split(' ') : opts.position;\n    var eRect = getSanitizedRect(opts.element, true);\n    var tRect = getSanitizedRect(opts.target);\n    var isContainDefined = isPlainObject(opts.contain);\n    var container = isContainDefined && opts.contain.within;\n    var overflowAction = isContainDefined && getOverflowAction(opts.contain.onOverflow);\n    var overflowFixLeft = 0;\n    var overflowFixTop = 0;\n    var offsetX = opts.offsetX;\n    var offsetY = opts.offsetY;\n    var cRect;\n    var overlap;\n    var eCurrentOffset;\n\n    // Sanitize offsets and check for percentage values.\n    offsetX = typeof offsetX === 'string' && offsetX.indexOf('%') > -1 ? toFloat(offsetX) / 100 * eRect.width : toFloat(offsetX);\n    offsetY = typeof offsetY === 'string' && offsetY.indexOf('%') > -1 ? toFloat(offsetY) / 100 * eRect.height : toFloat(offsetY);\n\n    // Calculate element's new position (left/top coordinates).\n    ret.left = getPlacePosition(position[0], position[2], tRect.width, tRect.left, eRect.width, eRect.left, offsetX);\n    ret.top = getPlacePosition(position[1], position[3], tRect.height, tRect.top, eRect.height, eRect.top, offsetY);\n\n    // Update element offset data to match the newly calculated position.\n    eRect.left += ret.left;\n    eRect.top += ret.top;\n\n    // If container element and overflow action are defined, let's handle\n    // container's possible overflow.\n    if (container && overflowAction) {\n\n      // Get container rect and overlap data.\n      cRect = getSanitizedRect(container);\n      overlap = getOverlap(eRect, cRect);\n\n      // Handle horizontal overflow.\n      if (overlap.left < 0 || overlap.right < 0) {\n        overflowFixLeft = getPlaceOverflowPush(overflowAction, overlap);\n        ret.left += overflowFixLeft;\n      }\n\n      // Handle vertical overflow.\n      if (overlap.top < 0 || overlap.bottom < 0) {\n        overflowFixTop = getPlaceOverflowPush(overflowAction, overlap, 1);\n        ret.top += overflowFixTop;\n      }\n\n    }\n\n    if (typeof opts.adjust === 'function') {\n\n      // Update element's left and right rect data to account for the possible\n      // overflow correction.\n      if (overflowFixLeft !== 0) {\n        eRect.left += overflowFixLeft;\n        eRect.right = eRect.left + eRect.width;\n      }\n\n      // Update element's top and bottom rect data to account for the possible\n      // overflow correction.\n      if (overflowFixTop !== 0) {\n        eRect.top += overflowFixTop;\n        eRect.bottom = eRect.left + eRect.width;\n      }\n\n      // Get container rect.\n      cRect = container ? cRect || getSanitizedRect(container) : null;\n\n      // Get the element's current offset so we can calculate how much the\n      // element moved.\n      eCurrentOffset = isPlainObject(opts.element) ? opts.element : getOffsetFromDocument.apply(null, [].concat(opts.element));\n\n      // Calculate overlap data based on the new position.\n      overlap = cRect ? getOverlap(eRect, cRect) : null;\n\n      // Provide the final position hash as the first argument (which can be\n      // modified and it affects the return value of this method) and all the\n      // positioning data as the second argument.\n      opts.adjust(ret, {\n        elementRect: eRect,\n        targetRect: tRect,\n        containerRect: cRect,\n        shift: {\n          left: eRect.left - eCurrentOffset.left,\n          top: eRect.top - eCurrentOffset.top\n        },\n        overflow: !overlap ? null : {\n          left: -overlap.left,\n          right: -overlap.right,\n          top: -overlap.top,\n          bottom: -overlap.bottom\n        },\n        overflowCorrection: {\n          left: overflowFixLeft,\n          top: overflowFixTop\n        }\n      });\n\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Private helper functions\n   * ************************\n   */\n\n  /**\n   * Check if a value is a plain object.\n   *\n   * @private\n   * @param {*} val\n   * @returns {Boolean}\n   */\n  function isPlainObject(val) {\n\n    return typeof val === 'object' && Object.prototype.toString.call(val) === '[object Object]';\n\n  }\n\n  /**\n   * Returns the supported transform property's prefix, property name and style\n   * name or null if transforms are not supported.\n   *\n   * @private\n   * @returns {?Object}\n   */\n  function getSupportedTransform() {\n\n    var transforms = ['transform', 'WebkitTransform', 'MozTransform', 'OTransform', 'msTransform'];\n\n    for (var i = 0; i < transforms.length; i++) {\n      if (root.style[transforms[i]] !== undefined) {\n\n        var prop = transforms[i];\n        var prefix = prop.toLowerCase().split('transform')[0];\n\n        return {\n          prefix: prefix,\n          propName: prop,\n          styleName: prefix ? '-' + prefix + '-transform' : prop\n        };\n\n      }\n    }\n\n    return null;\n\n  }\n\n  /**\n   * Detects if transformed elements leak fixed elements. According W3C\n   * transform rendering spec a transformed element should contain even fixed\n   * elements. Meaning that fixed elements are positioned relative to the\n   * closest transformed ancestor element instead of window. However, not every\n   * browser follows the spec (IE and older Firefox), so we need to test it.\n   * https://www.w3.org/TR/css3-2d-transforms/#transform-rendering\n   *\n   * @private\n   * @returns {Boolean}\n   *   - Returns true if transformed elements leak fixed elements, false\n   *     otherwise.\n   */\n  function doesTransformLeakFixed() {\n\n    if (!settings.transform) {\n      return true;\n    }\n\n    var outer = doc.createElement('div');\n    var inner = doc.createElement('div');\n    var leftNotTransformed;\n    var leftTransformed;\n\n    setStyles(outer, {\n      display: 'block',\n      visibility: 'hidden',\n      position: 'absolute',\n      width: '1px',\n      height: '1px',\n      left: '1px',\n      top: '0',\n      margin: '0'\n    });\n\n    setStyles(inner, {\n      display: 'block',\n      position: 'fixed',\n      width: '1px',\n      height: '1px',\n      left: '0',\n      top: '0',\n      margin: '0'\n    });\n\n    outer.appendChild(inner);\n    body.appendChild(outer);\n    leftNotTransformed = inner.getBoundingClientRect().left;\n    outer.style[settings.transform.propName] = 'translateX(0)';\n    leftTransformed = inner.getBoundingClientRect().left;\n    body.removeChild(outer);\n\n    return leftTransformed === leftNotTransformed;\n\n  }\n\n  /**\n   * Returns true if element is transformed, false if not. In practice the\n   * element's display value must be anything else than \"none\" or \"inline\" as\n   * well as have a valid transform value applied in order to be counted as a\n   * transformed element.\n   *\n   * @private\n   * @param {Element} el\n   * @returns {Boolean}\n   */\n  function isTransformed(el) {\n\n    var transform = getStyle(el, settings.transform.styleName);\n    var display = getStyle(el, 'display');\n\n    return transform !== 'none' && display !== 'inline' && display !== 'none';\n\n  }\n\n  /**\n   * Customized parseFloat function which returns 0 instead of NaN.\n   *\n   * @private\n   * @param {Number|String} val\n   * @returns {Number}\n   */\n  function toFloat(val) {\n\n    return parseFloat(val) || 0;\n\n  }\n\n  /**\n   * Deep merge an array of objects into a new object.\n   *\n   * @private\n   * @param {Array} array\n   * @returns {Object}\n   */\n  function mergeObjects(array) {\n\n    var ret = {};\n    var propName;\n    var propVal;\n\n    for (var i = 0, len = array.length; i < len; i++) {\n      for (propName in array[i]) {\n        if (array[i].hasOwnProperty(propName)) {\n          propVal = array[i][propName];\n          ret[propName] = isPlainObject(propVal) ? mergeObjects([propVal]) :\n                          Array.isArray(propVal) ? propVal.slice() :\n                                                   propVal;\n        }\n      }\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Returns the computed value of an element's style property as a string.\n   *\n   * @private\n   * @param {Element} el\n   * @param {String} style\n   * @returns {String}\n   */\n  function getStyle(el, style) {\n\n    return win.getComputedStyle(el, null).getPropertyValue(style);\n\n  }\n\n  /**\n   * Returns the computed value of an element's style property transformed into\n   * a float value.\n   *\n   * @private\n   * @param {Element} el\n   * @param {String} style\n   * @returns {Number}\n   */\n  function getStyleAsFloat(el, style) {\n\n    return toFloat(getStyle(el, style));\n\n  }\n\n  /**\n   * Set inline styles to an element.\n   *\n   * @private\n   * @param {Element} el\n   * @param {Object} styles\n   */\n  function setStyles(el, styles) {\n\n    Object.keys(styles).forEach(function (styleName) {\n      el.style[styleName] = styles[styleName];\n    });\n\n  }\n\n  /**\n   * Calculates how much element overlaps another element from each side.\n   *\n   * @private\n   * @param {(Array|Document|Element|Window|Rectangle)} elA\n   * @param {(Array|Document|Element|Window|Rectangle)} elB\n   * @returns {Overlap}\n   */\n  function getOverlap(elA, elB) {\n\n    var aRect = getSanitizedRect(elA);\n    var bRect = getSanitizedRect(elB);\n\n    return {\n      left: aRect.left - bRect.left,\n      right: (bRect.left + bRect.width) - (aRect.left + aRect.width),\n      top: aRect.top - bRect.top,\n      bottom: (bRect.top + bRect.height) - (aRect.top + aRect.height)\n    };\n\n  }\n\n  /**\n   * Detect if two elements overlap and calculate the possible intersection\n   * area's dimensions and offsets. If the intersection area exists the function\n   * returns an object containing the intersection area's dimensions and\n   * offsets. Otherwise null is returned.\n   *\n   * @private\n   * @param {(Array|Document|Element|Window|Rectangle)} elA\n   * @param {(Array|Document|Element|Window|Rectangle)} elB\n   * @returns {?RectangleExtended}\n   */\n  function getIntersection(elA, elB) {\n\n    var ret = {};\n    var aRect = getSanitizedRect(elA);\n    var bRect = getSanitizedRect(elB);\n    var overlap = getOverlap(aRect, bRect);\n    var intWidth = max(aRect.width + min(overlap.left, 0) + min(overlap.right, 0), 0);\n    var intHeight = max(aRect.height + min(overlap.top, 0) + min(overlap.bottom, 0), 0);\n    var hasIntersection = intWidth > 0 && intHeight > 0;\n\n    if (hasIntersection) {\n      ret.width = intWidth;\n      ret.height = intHeight;\n      ret.left = aRect.left + abs(min(overlap.left, 0));\n      ret.top = aRect.top + abs(min(overlap.top, 0));\n      ret.right = ret.left + ret.width;\n      ret.bottom = ret.top + ret.height;\n    }\n\n    return hasIntersection ? ret : null;\n\n  }\n\n  /**\n   * Calculates the distance between two points in 2D space.\n   *\n   * @private\n   * @param {Number} aLeft\n   * @param {Number} aTop\n   * @param {Number} bLeft\n   * @param {Number} bTop\n   * @returns {Number}\n   */\n  function getDistanceBetweenPoints(aLeft, aTop, bLeft, bTop) {\n\n    return Math.sqrt(Math.pow(bLeft - aLeft, 2) + Math.pow(bTop - aTop, 2));\n\n  }\n\n  /**\n   * Calculates the distance between two unrotated rectangles in 2D space. This\n   * function assumes that the rectangles do not intersect.\n   *\n   * @private\n   * @param {Rectangle} rectA\n   * @param {Rectangle} rectB\n   * @returns {Number}\n   */\n  function getDistanceBetweenRects(rectA, rectB) {\n\n    var ret = 0;\n    var aLeft = rectA.left;\n    var aRight = aLeft + rectA.width;\n    var aTop = rectA.top;\n    var aBottom = aTop + rectA.height;\n    var bLeft = rectB.left;\n    var bRight = bLeft + rectB.width;\n    var bTop = rectB.top;\n    var bBottom = bTop + rectB.height;\n\n    // Calculate shortest corner distance\n    if ((bLeft > aRight || bRight < aLeft) && (bTop > aBottom || bBottom < aTop)) {\n      if (bLeft > aRight) {\n        ret = bBottom < aTop ? getDistanceBetweenPoints(aRight, aTop, bLeft, bBottom) : getDistanceBetweenPoints(aRight, aBottom, bLeft, bTop);\n      }\n      else {\n        ret = bBottom < aTop ? getDistanceBetweenPoints(aLeft, aTop, bRight, bBottom) : getDistanceBetweenPoints(aLeft, aBottom, bRight, bTop);\n      }\n    }\n\n    // Calculate shortest edge distance\n    else {\n      ret = bBottom < aTop ? aTop - bBottom :\n            bLeft > aRight ? bLeft - aRight :\n            bTop > aBottom ? bTop - aBottom :\n            aLeft - bRight;\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Returns the height/width of an element in pixels. The function also accepts\n   * the window object (for obtaining the viewport dimensions) and the document\n   * object (for obtaining the dimensions of the document) in place of element.\n   * Note that this function considers root element's scrollbars as the\n   * document's and window's scrollbars also. Since the root element's\n   * scrollbars are always stuck on the right/bottom edge of the window (even if\n   * you specify width and/or height to root element) they are generally\n   * referred to as viewport scrollbars in the docs. Also note that only\n   * positive margins are included in the result when includeMargin argument is\n   * true.\n   *\n   * @private\n   * @param {String} dimension\n   *   - Accepts \"width\" or \"height\".\n   * @param {(Document|Element|Window)} el\n   * @param {Boolean} [includePadding=false]\n   * @param {Boolean} [includeScrollbar=false]\n   * @param {Boolean} [includeBorder=false]\n   * @param {Boolean} [includeMargin=false]\n   * @returns {Number}\n   *   - The return value may be fractional when calculating the width of an\n   *     element. For window and document objects the value is always an integer\n   *     though.\n   */\n  function getDimension(dimension, el, includePadding, includeScrollbar, includeBorder, includeMargin) {\n\n    var ret;\n    var isHeight = dimension === 'height';\n    var dimensionCapitalized = isHeight ? 'Height' : 'Width';\n    var innerDimension = 'inner' + dimensionCapitalized;\n    var clientDimension = 'client' + dimensionCapitalized;\n    var scrollDimension = 'scroll' + dimensionCapitalized;\n    var sbSize = 0;\n    var edgeA;\n    var edgeB;\n    var borderA;\n    var borderB;\n    var marginA;\n    var marginB;\n\n    if (el.self === win.self) {\n\n      ret = includeScrollbar ? win[innerDimension] : root[clientDimension];\n\n    }\n    else if (el === doc) {\n\n      if (includeScrollbar) {\n        sbSize = win[innerDimension] - root[clientDimension];\n        ret = max(root[scrollDimension] + sbSize, body[scrollDimension] + sbSize, win[innerDimension]);\n      }\n      else {\n        ret = max(root[scrollDimension], body[scrollDimension], root[clientDimension]);\n      }\n\n    }\n    else {\n\n      edgeA = isHeight ? 'top' : 'left';\n      edgeB = isHeight ? 'bottom' : 'right';\n      ret = (tempBCR || el.getBoundingClientRect())[dimension];\n\n      if (!includeScrollbar) {\n\n        if (el === root) {\n          sbSize = win[innerDimension] - root[clientDimension];\n        }\n        else if (unscrollableDisplayValues.indexOf(getStyle(el, 'display')) < 0) {\n          borderA = getStyleAsFloat(el, 'border-' + edgeA + '-width');\n          borderB = getStyleAsFloat(el, 'border-' + edgeB + '-width');\n          sbSize = Math.round(ret) - (el[clientDimension] + borderA + borderB);\n        }\n\n        ret -= sbSize > 0 ? sbSize : 0;\n\n      }\n\n      if (!includePadding) {\n        ret -= getStyleAsFloat(el, 'padding-' + edgeA);\n        ret -= getStyleAsFloat(el, 'padding-' + edgeB);\n      }\n\n      if (!includeBorder) {\n        ret -= borderA !== undefined ? borderA : getStyleAsFloat(el, 'border-' + edgeA + '-width');\n        ret -= borderB !== undefined ? borderB : getStyleAsFloat(el, 'border-' + edgeB + '-width');\n      }\n\n      if (includeMargin) {\n        marginA = getStyleAsFloat(el, 'margin-' + edgeA);\n        marginB = getStyleAsFloat(el, 'margin-' + edgeB);\n        ret += marginA > 0 ? marginA : 0;\n        ret += marginB > 0 ? marginB : 0;\n      }\n\n    }\n\n    return ret > 0 ? ret : 0;\n\n  }\n\n  /**\n   * Returns the element's (or window's) document offset, which in practice\n   * means the vertical and horizontal distance between the element's northwest\n   * corner and the document's northwest corner.\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} [edge='border']\n   * @returns {Offset}\n   */\n  function getOffsetFromDocument(el, edge) {\n\n    var ret = {\n      left: 0,\n      top: 0\n    };\n\n    // Document's offsets are always 0.\n    if (el === doc) {\n      return ret;\n    }\n\n    // Add viewport's scroll left/top to the respective offsets.\n    ret.left = win.pageXOffset || 0;\n    ret.top = win.pageYOffset || 0;\n\n    // Window's offsets are the viewport's scroll left/top values.\n    if (el.self === win.self) {\n      return ret;\n    }\n\n    // Now we know we are calculating an element's offsets so let's first get\n    // the element's bounding client rect. If it is not cached, then just fetch\n    // it.\n    var gbcr = tempBCR || el.getBoundingClientRect();\n\n    // Add bounding client rect's left/top values to the offsets.\n    ret.left += gbcr.left;\n    ret.top += gbcr.top;\n\n    // Sanitize edge.\n    edge = edge && edges[edge] || 4;\n\n    // Exclude element's positive margin size from the offset if needed.\n    if (edge === 5) {\n      var marginLeft = getStyleAsFloat(el, 'margin-left');\n      var marginTop = getStyleAsFloat(el, 'margin-top');\n      ret.left -= marginLeft > 0 ? marginLeft : 0;\n      ret.top -= marginTop > 0 ? marginTop : 0;\n    }\n\n    // Include element's border size to the offset if needed.\n    if (edge < 4) {\n      ret.left += getStyleAsFloat(el, 'border-left-width');\n      ret.top += getStyleAsFloat(el, 'border-top-width');\n    }\n\n    // Include element's padding size to the offset if needed.\n    if (edge === 1) {\n      ret.left += getStyleAsFloat(el, 'padding-left');\n      ret.top += getStyleAsFloat(el, 'padding-top');\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Returns an object containing the provided element's dimensions and offsets.\n   * This is basically just a wrapper for the getRectInternal function which\n   * does some argument normalization before doing the actal calculations. Used\n   * only internally.\n   *\n   * @private\n   * @param {(Array|Document|Element|Window|Rectangle)} el\n   * @param {Boolean} [useStaticOffset=false]\n   * @returns {?Rectangle}\n   */\n  function getSanitizedRect(el, useStaticOffset) {\n\n    // Can't have an empty value.\n    if (!el) {\n      return null;\n    }\n\n    // Let's assume that plain objects are static rectangle definitions.\n    if (isPlainObject(el)) {\n      return el;\n    }\n\n    // We don't know for sure if the provided element is defined with an edge\n    // layer (array syntax) or not. So let's play it safe an normalize the value\n    // to an array.\n    el = [].concat(el);\n\n    return getRectInternal(el[0], el[1], useStaticOffset);\n\n  }\n\n  /**\n   * Returns an object containing the provided element's dimensions and offsets.\n   * This is basically a helper method for calculating an element's dimensions\n   * and offsets simultaneously. Mimics the native getBoundingClientRect method\n   * with the added bonus of allowing to provide the \"edge\" of the element.\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} [edge='border']\n   * @param {Boolean} [useStaticOffset=false]\n   * @returns {Rectangle}\n   */\n  function getRectInternal(el, edge, useStaticOffset) {\n\n    var isElem = el !== doc && el.self !== win.self;\n    var rect;\n\n    // Sanitize edge.\n    edge = edge || 'border';\n\n    // If static offset is required we have to get it before temporary bounding\n    // client rect is cached, since it might need to get the offset of another\n    // element than the cached one.\n    if (useStaticOffset) {\n      rect = getStaticOffset(el, edge);\n    }\n\n    // Cache element's bounding client rect.\n    if (isElem) {\n      tempBCR = el.getBoundingClientRect();\n    }\n\n    // If static offset is not required we know for sure that the temporary\n    // bounding client rect is the same element we need to get offset for.\n    if (!useStaticOffset) {\n      rect = getOffsetFromDocument(el, edge);\n    }\n\n    // Get element's width and height.\n    rect.width = getWidth(el, edge);\n    rect.height = getHeight(el, edge);\n\n    // Calculate element's bottom and right.\n    rect.bottom = rect.top + rect.height;\n    rect.right = rect.left + rect.width;\n\n    // Nullify temporary bounding client rect cache.\n    if (isElem) {\n      tempBCR = null;\n    }\n\n    return rect;\n\n  }\n\n  /**\n   * Returns an element's static offset which in this case means the element's\n   * offset in a state where the element's left and top CSS properties are set\n   * to 0.\n   *\n   * @private\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} edge\n   * @returns {Offset}\n   */\n  function getStaticOffset(el, edge) {\n\n    // Sanitize edge.\n    edge = edge || 'border';\n\n    // For window and document just return normal offset.\n    if (el === win || el === doc) {\n      return getOffsetFromDocument(el, edge);\n    }\n\n    var position = getStyle(el, 'position');\n    var offset = position === 'absolute' || position === 'fixed' ? getOffsetFromDocument(getContainingBlock(el) || doc, 'padding') : getOffsetFromDocument(el, edge);\n\n    if (position === 'relative') {\n\n      var left = getStyle(el, 'left');\n      var right = getStyle(el, 'right');\n      var top = getStyle(el, 'top');\n      var bottom = getStyle(el, 'bottom');\n\n      if (left !== 'auto' || right !== 'auto') {\n        offset.left -= left === 'auto' ? -toFloat(right) : toFloat(left);\n      }\n\n      if (top !== 'auto' || bottom !== 'auto') {\n        offset.top -= top === 'auto' ? -toFloat(bottom) : toFloat(top);\n      }\n\n    }\n    else if (position === 'absolute' || position === 'fixed') {\n\n      // Get edge number.\n      edge = edges[edge];\n\n      // Get left and top margins.\n      var marginLeft = getStyleAsFloat(el, 'margin-left');\n      var marginTop = getStyleAsFloat(el, 'margin-top');\n\n      // If edge is \"margin\" remove negative left/top margins from offset to\n      // account for their effect on position.\n      if (edge === 5) {\n        offset.left -= abs(min(marginLeft, 0));\n        offset.top -= abs(min(marginTop, 0));\n      }\n\n      // If edge is \"border\" or smaller add positive left/top margins and remove\n      // negative left/top margins from offset to account for their effect on\n      // position.\n      if (edge < 5) {\n        offset.left += marginLeft;\n        offset.top += marginTop;\n      }\n\n      // If edge is \"scroll\" or smaller add left/top borders to offset to\n      // account for their effect on position.\n      if (edge < 4) {\n        offset.left += getStyleAsFloat(el, 'border-left-width');\n        offset.top += getStyleAsFloat(el, 'border-top-width');\n      }\n\n      // If edge is \"content\" add left/top paddings to offset to account for\n      // their effect on position.\n      if (edge === 1) {\n        offset.left += getStyleAsFloat(el, 'padding-left');\n        offset.top += getStyleAsFloat(el, 'padding-top');\n      }\n\n    }\n\n    return offset;\n\n  }\n\n  /**\n   * Returns the horizontal or vertical base position of an element relative to\n   * the target element. In other words, this function returns the left and top\n   * CSS values which should be set as to the target element in order to\n   * position it according to the desired position.\n   *\n   * @private\n   * @param {String} elementPosition\n   *   - Element's position: \"left\", \"right\", \"top\", \"bottom\" or \"center\".\n   * @param {String} targetPosition\n   *   - Target's position: \"left\", \"right\", \"top\", \"bottom\" or \"center\".\n   * @param {Number} targetSize\n   *   - Target's width/height in pixels.\n   * @param {Number} targetOffset\n   *   - Target's left/top offset in pixels.\n   * @param {Number} elementSize\n   *   - Element's width/height in pixels.\n   * @param {Number} elementNwOffset\n   *   - Element's left/top northwest offset in pixels.\n   * @param {Number} extraOffset\n   *   - Additional left/top offset in pixels.\n   * @returns {Number}\n   */\n  function getPlacePosition(elementPosition, targetPosition, targetSize, targetOffset, elementSize, elementNwOffset, extraOffset) {\n\n    var placement = elementPosition.charAt(0) + targetPosition.charAt(0);\n    var northwestPoint = targetOffset + extraOffset - elementNwOffset;\n\n    return placement === 'll' || placement === 'tt' ? northwestPoint :\n           placement === 'lc' || placement === 'tc' ? northwestPoint + (targetSize / 2) :\n           placement === 'lr' || placement === 'tb' ? northwestPoint + targetSize :\n           placement === 'cl' || placement === 'ct' ? northwestPoint - (elementSize / 2) :\n           placement === 'cr' || placement === 'cb' ? northwestPoint + targetSize - (elementSize / 2) :\n           placement === 'rl' || placement === 'bt' ? northwestPoint - elementSize :\n           placement === 'rc' || placement === 'bc' ? northwestPoint - elementSize + (targetSize / 2) :\n           placement === 'rr' || placement === 'bb' ? northwestPoint - elementSize + targetSize :\n                                                      northwestPoint + (targetSize / 2) - (elementSize / 2);\n\n  }\n\n  /**\n   * Calculates the distance in pixels that the element needs to be moved in\n   * order to be aligned correctly if the target element overlaps the container.\n   *\n   * @private\n   * @param {OverflowConfig} overflowConfig\n   * @param {Overlap} targetOverlap\n   * @param {Boolean} isVertical\n   * @returns {Number}\n   */\n  function getPlaceOverflowPush(overflowConfig, targetOverlap, isVertical) {\n\n    var ret = 0;\n    var push = 'push';\n    var forcePush = 'forcepush';\n    var sideA = isVertical ? 'top' : 'left';\n    var sideB = isVertical ? 'bottom' : 'right';\n    var sideAConfig = overflowConfig[sideA];\n    var sideBConfig = overflowConfig[sideB];\n    var sideAOverlap = targetOverlap[sideA];\n    var sideBOverlap = targetOverlap[sideB];\n    var sizeDifference = sideAOverlap + sideBOverlap;\n\n    // If pushing is needed from both sides.\n    if ((sideAConfig === push || sideAConfig === forcePush) && (sideBConfig === push || sideBConfig === forcePush) && (sideAOverlap < 0 || sideBOverlap < 0)) {\n\n      // Do push correction from opposite sides with equal force.\n      if (sideAOverlap < sideBOverlap) {\n        ret -= sizeDifference < 0 ? sideAOverlap + abs(sizeDifference / 2) : sideAOverlap;\n      }\n\n      // Do push correction from opposite sides with equal force.\n      if (sideBOverlap < sideAOverlap) {\n        ret += sizeDifference < 0 ? sideBOverlap + abs(sizeDifference / 2) : sideBOverlap;\n      }\n\n      // Update overlap data.\n      sideAOverlap += ret;\n      sideBOverlap -= ret;\n\n      // Check if left/top side forced push correction is needed.\n      if (sideAConfig === forcePush && sideBConfig !== forcePush && sideAOverlap < 0) {\n        ret -= sideAOverlap;\n      }\n\n      // Check if right/top side forced push correction is needed.\n      if (sideBConfig === forcePush && sideAConfig !== forcePush && sideBOverlap < 0) {\n        ret += sideBOverlap;\n      }\n\n    }\n\n    // Check if pushing is needed from left or top side only.\n    else if ((sideAConfig === forcePush || sideAConfig === push) && sideAOverlap < 0) {\n      ret -= sideAOverlap;\n    }\n\n    // Check if pushing is needed from right or bottom side only.\n    else if ((sideBConfig === forcePush || sideBConfig === push) && sideBOverlap < 0) {\n      ret += sideBOverlap;\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Sanitize contain.onOverflow option of .place() method.\n   *\n   * @private\n   * @param {OverflowConfig} overflowConfig\n   * @returns {?overflowConfigSanitized}\n   */\n  function getOverflowAction(overflowConfig) {\n\n    var actionType = typeof overflowConfig;\n    var left = 'none';\n    var right = 'none';\n    var top = 'none';\n    var bottom = 'none';\n\n    // onOverflow string value is always used for all sides.\n    if (actionType === 'string') {\n      left = right = top = bottom = overflowConfig;\n    }\n\n    // onOverflow object value can have properties that present a side\n    // (left/right/top/bottom) or an axis (x/y). Always try to use the side\n    // value first and then fallback to axis value. If all else fails fallback\n    // to \"none\".\n    else if (actionType === 'object') {\n      left = overflowConfig.left || overflowConfig.x || left;\n      right = overflowConfig.right || overflowConfig.x || right;\n      top = overflowConfig.top || overflowConfig.y || top;\n      bottom = overflowConfig.bottom || overflowConfig.y || bottom;\n    }\n\n    // If one side (or more) has a value other than \"none\" we know that the\n    // contain option might have an effect on the positioning.\n    if (left !== 'none' || right !== 'none' || top !== 'none' || bottom !== 'none') {\n      return {\n        left: left,\n        right: right,\n        top: top,\n        bottom: bottom\n      };\n    }\n\n    return null;\n\n  }\n\n  /**\n   * Custom type definitions\n   * ***********************\n   */\n\n  /**\n   * The browser's window object.\n   *\n   * @typedef {Object} Window\n   */\n\n  /**\n   * The document contained in browser's window object.\n   *\n   * @typedef {Object} Document\n   */\n\n  /**\n   * Any HTML element including root and body elements.\n   *\n   * @typedef {Object} Element\n   */\n\n  /**\n   * The name of an element's box model edge which allows you to decide which\n   * areas of the element you want to include in the calculations. Valid edge\n   * values are \"content\", \"padding\", \"scroll\", \"border\" and \"margin\", in that\n   * specific order. Note that \"scroll\" is not a valid element edge accroding to\n   * W3C spec, but it is used here to define whether or not the scrollbar's size\n   * should be included in the calculations. For window and document objects\n   * this argument behaves a bit differently since they cannot have any\n   * paddings, borders or margins. Only \"content\" (without vertical scrollbar’s\n   * width) and \"scroll\" (with vertical scrollbar’s width) are effective values.\n   * \"padding\" is normalized to \"content\" while \"border\" and \"margin\" are\n   * normalized to \"scroll\".\n   *\n   * @typedef {String} Edge\n   */\n\n  /**\n   * @typedef {Object} Rectangle\n   * @property {Number} left\n   *   - Element's horizontal distance from the left edge of the document.\n   * @property {Number} top\n   *   - Element's vertical distance from the top edge of the document.\n   * @property {Number} height\n   *   - Element's height.\n   * @property {Number} width\n   *   - Element's width.\n   */\n\n  /**\n   * @typedef {Object} RectangleExtended\n   * @property {Number} left\n   *   - Element's horizontal distance from the left edge of the document.\n   * @property {Number} right\n   *   - Element's horizontal distance from the left edge of the document plus\n   *     width.\n   * @property {Number} top\n   *   - Element's vertical distance from the top edge of the document\n   * @property {Number} bottom\n   *   - Element's vertical distance from the top edge of the document plus\n   *     height.\n   * @property {Number} height\n   *   - Element's height.\n   * @property {Number} width\n   *   - Element's width.\n   */\n\n  /**\n   * @typedef {Object} Offset\n   * @property {Number} left\n   *   - Element's horizontal distance from the left edge of the document,\n   *     window or other element.\n   * @property {Number} top\n   *   - Element's vertical distance from the top edge of the document, window,\n   *     or other element.\n   */\n\n  /**\n   * @typedef {Object} Overlap\n   * @property {Number} left\n   * @property {Number} top\n   * @property {Number} right\n   * @property {Number} bottom\n   */\n\n  /**\n   * @typedef {Object} Overflow\n   * @property {Number} left\n   * @property {Number} top\n   * @property {Number} right\n   * @property {Number} bottom\n   */\n\n  /**\n   * @typedef {Object} PlaceOptions\n   * @param {(Array|Document|Element|Window|Rectangle)} element\n   * @property {(Array|Document|Element|Window|Rectangle)} target\n   * @property {PlaceOptionsPosition} [position='left top left top']\n   * @property {Number} [offsetX=0]\n   * @property {Number} [offsetY=0]\n   * @property {?PlaceOptionsContainment} [contain=null]\n   */\n\n  /**\n   * Raw positioning data for position option of .place() method.\n   * String syntax: \"elemX elemY targetX targetY\".\n   * Array syntax: [\"elemX\", \"elemY\", \"targetX\", \"targetY\"].\n   * Possible values for elemX and targetX: \"left\", \"center\", \"right\".\n   * Possible values for elemY and targetY: \"top\", \"center\", \"bottom\".\n   *\n   * @typedef {(Array|String)} PlaceOptionsPosition\n   */\n\n  /**\n   * All properties accepts the following values: \"push\", \"forcepush\" and\n   * \"none\".\n   *\n   * @typedef {Object} PlaceOptionsContainment\n   * @property {?(Array|Document|Element|Window|Rectangle)} within\n   * @property {?(OverflowConfig|String)} onOverflow\n   */\n\n  /**\n   * All properties accepts the following values: \"push\", \"forcepush\" and\n   * \"none\". The properties left, right, top and bottom are used to define the\n   * overflow action that should be called when the positioned element overflows\n   * the container element from the respective side. Alternatively you can also\n   * use the properties x and y to define the overflow action per axis. If you\n   * mix side overflow properties with axis overflow properties remember that\n   * the side configuration overwrites the axis configuration.\n   *\n   * @typedef {Object} OverflowConfig\n   * @property {String} [left='none']\n   * @property {String} [right='none']\n   * @property {String} [top='none']\n   * @property {String} [bottom='none']\n   * @property {String} [x='none']\n   * @property {String} [y='none']\n   */\n\n  /**\n   * A sanitized configuration data object for contain.onOverflow option of\n   * .place() method.\n   *\n   * @typedef {Object} OverflowConfigSanitized\n   * @property {String} left\n   * @property {String} right\n   * @property {String} top\n   * @property {String} bottom\n   */\n\n  /**\n   * @typedef {Object} PlaceData\n   * @property {Number} left\n   *   - Target element's new left position.\n   * @property {Number} top\n   *   - Target element's new top position.\n   */\n\n  // Name and return the public methods.\n  return {\n    width: getWidth,\n    height: getHeight,\n    offset: getOffset,\n    rect: getRect,\n    containingBlock: getContainingBlock,\n    distance: getDistance,\n    intersection: getIntersectionMultiple,\n    overflow: getOverflow,\n    place: getPlace,\n    _settings: settings\n  };\n\n}));\n","'use strict';\nconst strictUriEncode = require('strict-uri-encode');\nconst decodeComponent = require('decode-uri-component');\nconst splitOnFirst = require('split-on-first');\nconst filterObject = require('filter-obj');\n\nconst isNullOrUndefined = value => value === null || value === undefined;\n\nconst encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');\n\nfunction encoderForArrayFormat(options) {\n\tswitch (options.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tconst index = result.length;\n\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), '[', index, ']'].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [\n\t\t\t\t\t...result,\n\t\t\t\t\t[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')\n\t\t\t\t];\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), '[]'].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), '[]=', encode(value, options)].join('')];\n\t\t\t};\n\n\t\tcase 'colon-list-separator':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), ':list='].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), ':list=', encode(value, options)].join('')];\n\t\t\t};\n\n\t\tcase 'comma':\n\t\tcase 'separator':\n\t\tcase 'bracket-separator': {\n\t\t\tconst keyValueSep = options.arrayFormat === 'bracket-separator' ?\n\t\t\t\t'[]=' :\n\t\t\t\t'=';\n\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t// Translate null to an empty string so that it doesn't serialize as 'null'\n\t\t\t\tvalue = value === null ? '' : value;\n\n\t\t\t\tif (result.length === 0) {\n\t\t\t\t\treturn [[encode(key, options), keyValueSep, encode(value, options)].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [[result, encode(value, options)].join(options.arrayFormatSeparator)];\n\t\t\t};\n\t\t}\n\n\t\tdefault:\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, encode(key, options)];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), '=', encode(value, options)].join('')];\n\t\t\t};\n\t}\n}\n\nfunction parserForArrayFormat(options) {\n\tlet result;\n\n\tswitch (options.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /\\[(\\d*)\\]$/.exec(key);\n\n\t\t\t\tkey = key.replace(/\\[\\d*\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = {};\n\t\t\t\t}\n\n\t\t\t\taccumulator[key][result[1]] = value;\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /(\\[\\])$/.exec(key);\n\t\t\t\tkey = key.replace(/\\[\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\n\t\tcase 'colon-list-separator':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /(:list)$/.exec(key);\n\t\t\t\tkey = key.replace(/:list$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\n\t\tcase 'comma':\n\t\tcase 'separator':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tconst isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);\n\t\t\t\tconst isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));\n\t\t\t\tvalue = isEncodedArray ? decode(value, options) : value;\n\t\t\t\tconst newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);\n\t\t\t\taccumulator[key] = newValue;\n\t\t\t};\n\n\t\tcase 'bracket-separator':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tconst isArray = /(\\[\\])$/.test(key);\n\t\t\t\tkey = key.replace(/\\[\\]$/, '');\n\n\t\t\t\tif (!isArray) {\n\t\t\t\t\taccumulator[key] = value ? decode(value, options) : value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst arrayValue = value === null ?\n\t\t\t\t\t[] :\n\t\t\t\t\tvalue.split(options.arrayFormatSeparator).map(item => decode(item, options));\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = arrayValue;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], arrayValue);\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\t}\n}\n\nfunction validateArrayFormatSeparator(value) {\n\tif (typeof value !== 'string' || value.length !== 1) {\n\t\tthrow new TypeError('arrayFormatSeparator must be single character string');\n\t}\n}\n\nfunction encode(value, options) {\n\tif (options.encode) {\n\t\treturn options.strict ? strictUriEncode(value) : encodeURIComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction decode(value, options) {\n\tif (options.decode) {\n\t\treturn decodeComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction keysSorter(input) {\n\tif (Array.isArray(input)) {\n\t\treturn input.sort();\n\t}\n\n\tif (typeof input === 'object') {\n\t\treturn keysSorter(Object.keys(input))\n\t\t\t.sort((a, b) => Number(a) - Number(b))\n\t\t\t.map(key => input[key]);\n\t}\n\n\treturn input;\n}\n\nfunction removeHash(input) {\n\tconst hashStart = input.indexOf('#');\n\tif (hashStart !== -1) {\n\t\tinput = input.slice(0, hashStart);\n\t}\n\n\treturn input;\n}\n\nfunction getHash(url) {\n\tlet hash = '';\n\tconst hashStart = url.indexOf('#');\n\tif (hashStart !== -1) {\n\t\thash = url.slice(hashStart);\n\t}\n\n\treturn hash;\n}\n\nfunction extract(input) {\n\tinput = removeHash(input);\n\tconst queryStart = input.indexOf('?');\n\tif (queryStart === -1) {\n\t\treturn '';\n\t}\n\n\treturn input.slice(queryStart + 1);\n}\n\nfunction parseValue(value, options) {\n\tif (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {\n\t\tvalue = Number(value);\n\t} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {\n\t\tvalue = value.toLowerCase() === 'true';\n\t}\n\n\treturn value;\n}\n\nfunction parse(query, options) {\n\toptions = Object.assign({\n\t\tdecode: true,\n\t\tsort: true,\n\t\tarrayFormat: 'none',\n\t\tarrayFormatSeparator: ',',\n\t\tparseNumbers: false,\n\t\tparseBooleans: false\n\t}, options);\n\n\tvalidateArrayFormatSeparator(options.arrayFormatSeparator);\n\n\tconst formatter = parserForArrayFormat(options);\n\n\t// Create an object with no prototype\n\tconst ret = Object.create(null);\n\n\tif (typeof query !== 'string') {\n\t\treturn ret;\n\t}\n\n\tquery = query.trim().replace(/^[?#&]/, '');\n\n\tif (!query) {\n\t\treturn ret;\n\t}\n\n\tfor (const param of query.split('&')) {\n\t\tif (param === '') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet [key, value] = splitOnFirst(options.decode ? param.replace(/\\+/g, ' ') : param, '=');\n\n\t\t// Missing `=` should be `null`:\n\t\t// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\t\tvalue = value === undefined ? null : ['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? value : decode(value, options);\n\t\tformatter(decode(key, options), value, ret);\n\t}\n\n\tfor (const key of Object.keys(ret)) {\n\t\tconst value = ret[key];\n\t\tif (typeof value === 'object' && value !== null) {\n\t\t\tfor (const k of Object.keys(value)) {\n\t\t\t\tvalue[k] = parseValue(value[k], options);\n\t\t\t}\n\t\t} else {\n\t\t\tret[key] = parseValue(value, options);\n\t\t}\n\t}\n\n\tif (options.sort === false) {\n\t\treturn ret;\n\t}\n\n\treturn (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {\n\t\tconst value = ret[key];\n\t\tif (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {\n\t\t\t// Sort object keys, not values\n\t\t\tresult[key] = keysSorter(value);\n\t\t} else {\n\t\t\tresult[key] = value;\n\t\t}\n\n\t\treturn result;\n\t}, Object.create(null));\n}\n\nexports.extract = extract;\nexports.parse = parse;\n\nexports.stringify = (object, options) => {\n\tif (!object) {\n\t\treturn '';\n\t}\n\n\toptions = Object.assign({\n\t\tencode: true,\n\t\tstrict: true,\n\t\tarrayFormat: 'none',\n\t\tarrayFormatSeparator: ','\n\t}, options);\n\n\tvalidateArrayFormatSeparator(options.arrayFormatSeparator);\n\n\tconst shouldFilter = key => (\n\t\t(options.skipNull && isNullOrUndefined(object[key])) ||\n\t\t(options.skipEmptyString && object[key] === '')\n\t);\n\n\tconst formatter = encoderForArrayFormat(options);\n\n\tconst objectCopy = {};\n\n\tfor (const key of Object.keys(object)) {\n\t\tif (!shouldFilter(key)) {\n\t\t\tobjectCopy[key] = object[key];\n\t\t}\n\t}\n\n\tconst keys = Object.keys(objectCopy);\n\n\tif (options.sort !== false) {\n\t\tkeys.sort(options.sort);\n\t}\n\n\treturn keys.map(key => {\n\t\tconst value = object[key];\n\n\t\tif (value === undefined) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (value === null) {\n\t\t\treturn encode(key, options);\n\t\t}\n\n\t\tif (Array.isArray(value)) {\n\t\t\tif (value.length === 0 && options.arrayFormat === 'bracket-separator') {\n\t\t\t\treturn encode(key, options) + '[]';\n\t\t\t}\n\n\t\t\treturn value\n\t\t\t\t.reduce(formatter(key), [])\n\t\t\t\t.join('&');\n\t\t}\n\n\t\treturn encode(key, options) + '=' + encode(value, options);\n\t}).filter(x => x.length > 0).join('&');\n};\n\nexports.parseUrl = (url, options) => {\n\toptions = Object.assign({\n\t\tdecode: true\n\t}, options);\n\n\tconst [url_, hash] = splitOnFirst(url, '#');\n\n\treturn Object.assign(\n\t\t{\n\t\t\turl: url_.split('?')[0] || '',\n\t\t\tquery: parse(extract(url), options)\n\t\t},\n\t\toptions && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}\n\t);\n};\n\nexports.stringifyUrl = (object, options) => {\n\toptions = Object.assign({\n\t\tencode: true,\n\t\tstrict: true,\n\t\t[encodeFragmentIdentifier]: true\n\t}, options);\n\n\tconst url = removeHash(object.url).split('?')[0] || '';\n\tconst queryFromUrl = exports.extract(object.url);\n\tconst parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});\n\n\tconst query = Object.assign(parsedQueryFromUrl, object.query);\n\tlet queryString = exports.stringify(query, options);\n\tif (queryString) {\n\t\tqueryString = `?${queryString}`;\n\t}\n\n\tlet hash = getHash(object.url);\n\tif (object.fragmentIdentifier) {\n\t\thash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;\n\t}\n\n\treturn `${url}${queryString}${hash}`;\n};\n\nexports.pick = (input, filter, options) => {\n\toptions = Object.assign({\n\t\tparseFragmentIdentifier: true,\n\t\t[encodeFragmentIdentifier]: false\n\t}, options);\n\n\tconst {url, query, fragmentIdentifier} = exports.parseUrl(input, options);\n\treturn exports.stringifyUrl({\n\t\turl,\n\t\tquery: filterObject(query, filter),\n\t\tfragmentIdentifier\n\t}, options);\n};\n\nexports.exclude = (input, filter, options) => {\n\tconst exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);\n\n\treturn exports.pick(input, exclusionFilter, options);\n};\n","'use strict';\n\nmodule.exports = (string, separator) => {\n\tif (!(typeof string === 'string' && typeof separator === 'string')) {\n\t\tthrow new TypeError('Expected the arguments to be of type `string`');\n\t}\n\n\tif (separator === '') {\n\t\treturn [string];\n\t}\n\n\tconst separatorIndex = string.indexOf(separator);\n\n\tif (separatorIndex === -1) {\n\t\treturn [string];\n\t}\n\n\treturn [\n\t\tstring.slice(0, separatorIndex),\n\t\tstring.slice(separatorIndex + separator.length)\n\t];\n};\n","'use strict';\nmodule.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);\n"],"names":["token","singleMatcher","RegExp","multiMatcher","decodeComponents","components","split","decodeURIComponent","join","err","length","left","slice","right","Array","prototype","concat","call","decode","input","tokens","match","i","customDecodeURIComponent","replaceMap","exec","result","entries","Object","keys","key","replace","module","exports","encodedURI","TypeError","obj","predicate","ret","isArr","isArray","val","indexOf","global","factory","this","undefined","win","document","self","defaultView","window","doc","root","documentElement","body","Error","tempBCR","abs","Math","max","min","edges","content","padding","scroll","border","margin","unscrollableDisplayValues","settings","getWidth","el","edge","getDimension","getHeight","getOffset","elemA","elemB","offsetA","isPlainObject","getOffsetFromDocument","offsetB","top","getRect","rect","getRectInternal","offsetFrom","getContainingBlock","fakePosition","scrollProps","parent","style","position","getStyle","transformLeaksFixed","parentElement","isTransformed","parentNode","getDistance","a","b","aRect","getSanitizedRect","bRect","getIntersection","getDistanceBetweenRects","getIntersectionMultiple","intersection","arguments","getOverflow","elA","elB","getOverlap","bottom","getPlace","options","cRect","overlap","eCurrentOffset","opts","mergeObjects","placeDefaultOptions","eRect","element","tRect","target","isContainDefined","contain","container","within","overflowAction","getOverflowAction","onOverflow","overflowFixLeft","overflowFixTop","offsetX","offsetY","toFloat","width","height","getPlacePosition","getPlaceOverflowPush","adjust","apply","elementRect","targetRect","containerRect","shift","overflow","overflowCorrection","toString","getSupportedTransform","transforms","prop","prefix","toLowerCase","propName","styleName","doesTransformLeakFixed","transform","leftNotTransformed","leftTransformed","outer","createElement","inner","setStyles","display","visibility","appendChild","getBoundingClientRect","removeChild","parseFloat","array","propVal","len","hasOwnProperty","getComputedStyle","getPropertyValue","getStyleAsFloat","styles","forEach","intWidth","intHeight","hasIntersection","getDistanceBetweenPoints","aLeft","aTop","bLeft","bTop","sqrt","pow","rectA","rectB","aRight","aBottom","bRight","bBottom","dimension","includePadding","includeScrollbar","includeBorder","includeMargin","edgeA","edgeB","borderA","borderB","marginA","marginB","isHeight","dimensionCapitalized","innerDimension","clientDimension","scrollDimension","sbSize","round","pageXOffset","pageYOffset","gbcr","marginLeft","marginTop","useStaticOffset","isElem","getStaticOffset","offset","elementPosition","targetPosition","targetSize","targetOffset","elementSize","elementNwOffset","extraOffset","placement","charAt","northwestPoint","overflowConfig","targetOverlap","isVertical","push","forcePush","sideA","sideB","sideAConfig","sideBConfig","sideAOverlap","sideBOverlap","sizeDifference","actionType","x","y","containingBlock","distance","place","_settings","strictUriEncode","decodeComponent","splitOnFirst","filterObject","isNullOrUndefined","value","encodeFragmentIdentifier","Symbol","encoderForArrayFormat","arrayFormat","index","skipNull","skipEmptyString","encode","keyValueSep","arrayFormatSeparator","parserForArrayFormat","accumulator","includes","isEncodedArray","newValue","map","item","test","arrayValue","validateArrayFormatSeparator","strict","encodeURIComponent","keysSorter","sort","Number","removeHash","hashStart","getHash","url","hash","extract","queryStart","parseValue","parseNumbers","isNaN","trim","parseBooleans","parse","query","assign","formatter","create","param","k","reduce","Boolean","stringify","object","shouldFilter","objectCopy","filter","parseUrl","url_","parseFragmentIdentifier","fragmentIdentifier","stringifyUrl","queryFromUrl","parsedQueryFromUrl","queryString","pick","exclude","exclusionFilter","string","separator","separatorIndex","str","charCodeAt","toUpperCase"],"sourceRoot":""}