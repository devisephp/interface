{"version":3,"sources":["webpack:///./node_modules/query-string/node_modules/strict-uri-encode/index.js","webpack:///./node_modules/query-string/index.js","webpack:///./node_modules/decode-uri-component/index.js","webpack:///./node_modules/split-on-first/index.js","webpack:///./node_modules/mezr/mezr.js"],"names":["module","exports","str","encodeURIComponent","replace","x","charCodeAt","toString","toUpperCase","strictUriEncode","decodeComponent","splitOnFirst","encoderForArrayFormat","options","arrayFormat","key","result","value","index","length","undefined","skipNull","encode","join","parserForArrayFormat","accumulator","exec","concat","isArray","split","indexOf","newValue","strict","decode","keysSorter","input","Array","sort","Object","keys","a","b","Number","map","removeHash","hashStart","slice","extract","queryStart","parseValue","parseNumbers","isNaN","trim","parseBooleans","toLowerCase","parse","assign","formatter","ret","create","param","k","reduce","Boolean","stringify","object","objectCopy","filter","parseUrl","url","query","token","singleMatcher","RegExp","multiMatcher","decodeComponents","components","decodeURIComponent","err","left","right","prototype","call","tokens","match","i","customDecodeURIComponent","replaceMap","entries","encodedURI","TypeError","string","separator","separatorIndex","global","factory","this","win","document","self","defaultView","window","doc","root","documentElement","body","Error","tempBCR","abs","Math","max","min","edges","content","padding","scroll","border","margin","unscrollableDisplayValues","settings","getWidth","el","edge","getDimension","getHeight","getOffset","elemA","elemB","offsetA","isPlainObject","getOffsetFromDocument","offsetB","top","getRect","rect","getRectInternal","offsetFrom","getContainingBlock","fakePosition","scrollProps","parent","style","position","getStyle","transformLeaksFixed","parentElement","isTransformed","parentNode","getDistance","aRect","getSanitizedRect","bRect","getIntersection","getDistanceBetweenRects","getIntersectionMultiple","intersection","arguments","getOverflow","elA","elB","getOverlap","bottom","getPlace","cRect","overlap","eCurrentOffset","opts","mergeObjects","placeDefaultOptions","eRect","element","tRect","target","isContainDefined","contain","container","within","overflowAction","getOverflowAction","onOverflow","overflowFixLeft","overflowFixTop","offsetX","offsetY","toFloat","width","height","getPlacePosition","getPlaceOverflowPush","adjust","apply","elementRect","targetRect","containerRect","shift","overflow","overflowCorrection","val","getSupportedTransform","transforms","prop","prefix","propName","styleName","doesTransformLeakFixed","transform","leftNotTransformed","leftTransformed","outer","createElement","inner","setStyles","display","visibility","appendChild","getBoundingClientRect","removeChild","parseFloat","array","propVal","len","hasOwnProperty","getComputedStyle","getPropertyValue","getStyleAsFloat","styles","forEach","intWidth","intHeight","hasIntersection","getDistanceBetweenPoints","aLeft","aTop","bLeft","bTop","sqrt","pow","rectA","rectB","aRight","aBottom","bRight","bBottom","dimension","includePadding","includeScrollbar","includeBorder","includeMargin","edgeA","edgeB","borderA","borderB","marginA","marginB","isHeight","dimensionCapitalized","innerDimension","clientDimension","scrollDimension","sbSize","round","pageXOffset","pageYOffset","gbcr","marginLeft","marginTop","useStaticOffset","isElem","getStaticOffset","offset","elementPosition","targetPosition","targetSize","targetOffset","elementSize","elementNwOffset","extraOffset","placement","charAt","northwestPoint","overflowConfig","targetOverlap","isVertical","push","forcePush","sideA","sideB","sideAConfig","sideBConfig","sideAOverlap","sideBOverlap","sizeDifference","actionType","y","containingBlock","distance","place","_settings"],"mappings":"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","file":"js/devise-slice-admin.aacd9c57.js","sourcesContent":["'use strict';\nmodule.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);\n","'use strict';\nconst strictUriEncode = require('strict-uri-encode');\nconst decodeComponent = require('decode-uri-component');\nconst splitOnFirst = require('split-on-first');\n\nfunction encoderForArrayFormat(options) {\n\tswitch (options.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tconst index = result.length;\n\t\t\t\tif (value === undefined || (options.skipNull && value === null)) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), '[', index, ']'].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [\n\t\t\t\t\t...result,\n\t\t\t\t\t[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')\n\t\t\t\t];\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (value === undefined || (options.skipNull && value === null)) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), '[]'].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), '[]=', encode(value, options)].join('')];\n\t\t\t};\n\n\t\tcase 'comma':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (value === null || value === undefined || value.length === 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (result.length === 0) {\n\t\t\t\t\treturn [[encode(key, options), '=', encode(value, options)].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [[result, encode(value, options)].join(',')];\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (value === undefined || (options.skipNull && value === null)) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, encode(key, options)];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), '=', encode(value, options)].join('')];\n\t\t\t};\n\t}\n}\n\nfunction parserForArrayFormat(options) {\n\tlet result;\n\n\tswitch (options.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /\\[(\\d*)\\]$/.exec(key);\n\n\t\t\t\tkey = key.replace(/\\[\\d*\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = {};\n\t\t\t\t}\n\n\t\t\t\taccumulator[key][result[1]] = value;\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /(\\[\\])$/.exec(key);\n\t\t\t\tkey = key.replace(/\\[\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\n\t\tcase 'comma':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tconst isArray = typeof value === 'string' && value.split('').indexOf(',') > -1;\n\t\t\t\tconst newValue = isArray ? value.split(',') : value;\n\t\t\t\taccumulator[key] = newValue;\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\t}\n}\n\nfunction encode(value, options) {\n\tif (options.encode) {\n\t\treturn options.strict ? strictUriEncode(value) : encodeURIComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction decode(value, options) {\n\tif (options.decode) {\n\t\treturn decodeComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction keysSorter(input) {\n\tif (Array.isArray(input)) {\n\t\treturn input.sort();\n\t}\n\n\tif (typeof input === 'object') {\n\t\treturn keysSorter(Object.keys(input))\n\t\t\t.sort((a, b) => Number(a) - Number(b))\n\t\t\t.map(key => input[key]);\n\t}\n\n\treturn input;\n}\n\nfunction removeHash(input) {\n\tconst hashStart = input.indexOf('#');\n\tif (hashStart !== -1) {\n\t\tinput = input.slice(0, hashStart);\n\t}\n\n\treturn input;\n}\n\nfunction extract(input) {\n\tinput = removeHash(input);\n\tconst queryStart = input.indexOf('?');\n\tif (queryStart === -1) {\n\t\treturn '';\n\t}\n\n\treturn input.slice(queryStart + 1);\n}\n\nfunction parseValue(value, options) {\n\tif (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {\n\t\tvalue = Number(value);\n\t} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {\n\t\tvalue = value.toLowerCase() === 'true';\n\t}\n\n\treturn value;\n}\n\nfunction parse(input, options) {\n\toptions = Object.assign({\n\t\tdecode: true,\n\t\tsort: true,\n\t\tarrayFormat: 'none',\n\t\tparseNumbers: false,\n\t\tparseBooleans: false\n\t}, options);\n\n\tconst formatter = parserForArrayFormat(options);\n\n\t// Create an object with no prototype\n\tconst ret = Object.create(null);\n\n\tif (typeof input !== 'string') {\n\t\treturn ret;\n\t}\n\n\tinput = input.trim().replace(/^[?#&]/, '');\n\n\tif (!input) {\n\t\treturn ret;\n\t}\n\n\tfor (const param of input.split('&')) {\n\t\tlet [key, value] = splitOnFirst(options.decode ? param.replace(/\\+/g, ' ') : param, '=');\n\n\t\t// Missing `=` should be `null`:\n\t\t// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\t\tvalue = value === undefined ? null : decode(value, options);\n\t\tformatter(decode(key, options), value, ret);\n\t}\n\n\tfor (const key of Object.keys(ret)) {\n\t\tconst value = ret[key];\n\t\tif (typeof value === 'object' && value !== null) {\n\t\t\tfor (const k of Object.keys(value)) {\n\t\t\t\tvalue[k] = parseValue(value[k], options);\n\t\t\t}\n\t\t} else {\n\t\t\tret[key] = parseValue(value, options);\n\t\t}\n\t}\n\n\tif (options.sort === false) {\n\t\treturn ret;\n\t}\n\n\treturn (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {\n\t\tconst value = ret[key];\n\t\tif (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {\n\t\t\t// Sort object keys, not values\n\t\t\tresult[key] = keysSorter(value);\n\t\t} else {\n\t\t\tresult[key] = value;\n\t\t}\n\n\t\treturn result;\n\t}, Object.create(null));\n}\n\nexports.extract = extract;\nexports.parse = parse;\n\nexports.stringify = (object, options) => {\n\tif (!object) {\n\t\treturn '';\n\t}\n\n\toptions = Object.assign({\n\t\tencode: true,\n\t\tstrict: true,\n\t\tarrayFormat: 'none'\n\t}, options);\n\n\tconst formatter = encoderForArrayFormat(options);\n\n\tconst objectCopy = Object.assign({}, object);\n\tif (options.skipNull) {\n\t\tfor (const key of Object.keys(objectCopy)) {\n\t\t\tif (objectCopy[key] === undefined || objectCopy[key] === null) {\n\t\t\t\tdelete objectCopy[key];\n\t\t\t}\n\t\t}\n\t}\n\n\tconst keys = Object.keys(objectCopy);\n\n\tif (options.sort !== false) {\n\t\tkeys.sort(options.sort);\n\t}\n\n\treturn keys.map(key => {\n\t\tconst value = object[key];\n\n\t\tif (value === undefined) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (value === null) {\n\t\t\treturn encode(key, options);\n\t\t}\n\n\t\tif (Array.isArray(value)) {\n\t\t\treturn value\n\t\t\t\t.reduce(formatter(key), [])\n\t\t\t\t.join('&');\n\t\t}\n\n\t\treturn encode(key, options) + '=' + encode(value, options);\n\t}).filter(x => x.length > 0).join('&');\n};\n\nexports.parseUrl = (input, options) => {\n\treturn {\n\t\turl: removeHash(input).split('?')[0] || '',\n\t\tquery: parse(extract(input), options)\n\t};\n};\n","'use strict';\nvar token = '%[a-f0-9]{2}';\nvar singleMatcher = new RegExp(token, 'gi');\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn decodeURIComponent(components.join(''));\n\t} catch (err) {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tvar left = components.slice(0, split);\n\tvar right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch (err) {\n\t\tvar tokens = input.match(singleMatcher);\n\n\t\tfor (var i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher);\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tvar replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD'\n\t};\n\n\tvar match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch (err) {\n\t\t\tvar result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tvar entries = Object.keys(replaceMap);\n\n\tfor (var i = 0; i < entries.length; i++) {\n\t\t// Replace all decoded components\n\t\tvar key = entries[i];\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nmodule.exports = function (encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\tencodedURI = encodedURI.replace(/\\+/g, ' ');\n\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch (err) {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n};\n","'use strict';\n\nmodule.exports = (string, separator) => {\n\tif (!(typeof string === 'string' && typeof separator === 'string')) {\n\t\tthrow new TypeError('Expected the arguments to be of type `string`');\n\t}\n\n\tif (separator === '') {\n\t\treturn [string];\n\t}\n\n\tconst separatorIndex = string.indexOf(separator);\n\n\tif (separatorIndex === -1) {\n\t\treturn [string];\n\t}\n\n\treturn [\n\t\tstring.slice(0, separatorIndex),\n\t\tstring.slice(separatorIndex + separator.length)\n\t];\n};\n","/*!\n * mezr v0.6.2\n * https://github.com/niklasramo/mezr\n * Copyright (c) 2016 Niklas Rämö <inramo@gmail.com>\n * Released under the MIT license\n */\n\n(function (global, factory) {\n\n  if (typeof define === 'function' && define.amd) {\n    define([], function () {\n      return factory(global);\n    });\n  }\n  else if (typeof module === 'object' && module.exports) {\n    module.exports = factory(global);\n  }\n  else {\n    global.mezr = factory(global);\n  }\n\n}(this, function (global, undefined) {\n\n  'use strict';\n\n  // Make sure we received a valid window object from the arguments.\n  var win = global.document && global.self === global.document.defaultView ? global : window;\n\n  // Cache document, root and body elements.\n  var doc = win.document;\n  var root = doc.documentElement;\n  var body = doc.body;\n\n  // Throw error if body is not available\n  if (!body) {\n    throw Error('Mezr needs access to body element.');\n  }\n\n  // Cache some often used native functions.\n  var abs = Math.abs;\n  var max = Math.max;\n  var min = Math.min;\n\n  // String to number mappings for element edges.\n  var edges = {\n    content: 1,\n    padding: 2,\n    scroll: 3,\n    border: 4,\n    margin: 5\n  };\n\n  // CSS display values which make it impossible for an element to have a\n  // scrollbar.\n  var unscrollableDisplayValues = ['inline', 'table-column', 'table-column-group'];\n\n  // Temporary bounding client rect data.\n  var tempBCR;\n\n  // Mezr settings.\n  var settings = {};\n\n  // Default options for place method.\n  settings.placeDefaultOptions = {\n    element: null,\n    target: null,\n    position: 'left top left top',\n    offsetX: 0,\n    offsetY: 0,\n    contain: null,\n    adjust: null\n  };\n\n  // Get the primary supported transform property.\n  settings.transform = getSupportedTransform();\n\n  // Check if transformed elements leak fixed elements? According W3C\n  // specification (about transform rendering) a transformed element should\n  // contain fixed elements, but not every browser follows the spec. So we need\n  // to test it.\n  settings.transformLeaksFixed = doesTransformLeakFixed();\n\n  /**\n   * Public methods\n   * **************\n   */\n\n  /**\n   * Returns the width of an element in pixels. Accepts also the window object\n   * (for getting the viewport width) and the document object (for getting the\n   * document width) in place of element.\n   *\n   * @example\n   * mezr.width(elemA, 'content');\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} [edge='border']\n   * @returns {Number}\n   *   - The return value may be fractional when calculating the width of an\n   *     element. For window and document objects the value is always an integer\n   *     though.\n   */\n  function getWidth(el, edge) {\n\n    edge = edge && edges[edge] || 4;\n\n    return getDimension('width', el, edge > 1, edge > 2, edge > 3, edge > 4);\n\n  }\n\n  /**\n   * Returns the height of an element in pixels. Accepts also the window object\n   * (for getting the viewport height) and the document object (for getting the\n   * document height) in place of element.\n   *\n   * @example\n   * mezr.height(elemA, 'content');\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} [edge='border']\n   * @returns {Number}\n   *   - The return value may be fractional when calculating the width of an\n   *     element. For window and document objects the value is always an integer\n   *     though.\n   */\n  function getHeight(el, edge) {\n\n    edge = edge && edges[edge] || 4;\n\n    return getDimension('height', el, edge > 1, edge > 2, edge > 3, edge > 4);\n\n  }\n\n  /**\n   * Returns the element's offset from another element, window or document. In\n   * practice the offset means the vertical and horizontal distance from the\n   * comparison element's northwest corner to the target element's northwest\n   * corner. By default the comparison element is considered to be the document.\n   *\n   * @example\n   * // Returns offset from document's northwest corner to elemA's content\n   * // layer's northwest corner.\n   * mezr.offset(elemA, 'content');\n   *\n   * @example\n   * // Returns offset from window's northwest corner to elemA's content layer's\n   * // northwest corner.\n   * mezr.offset([elemA, 'content'], window);\n   *\n   * @example\n   * // Returns offset from elemB's margin layer's northwest corner to elemA's\n   * // content layer's northwest corner.\n   * mezr.offset([elemA, 'padding'], [elemB, 'margin']);\n   *\n   * @public\n   * @param {(Array|Document|Element|Rectangle|Window)} el\n   * @param {(Array|Document|Edge|Element|Rectangle|Window)} [edge='border']\n   *   - If this argument is a string it is considered to be an edge layer\n   *     definition for the first argument. Otherwise this is considered to be a\n   *     defintion of an element, document or window.\n   * @returns {Offset}\n   */\n  function getOffset(el, edge) {\n\n    // Use default syntax if the element is not an array and the edge is\n    // undefined or a string.\n    if (!Array.isArray(el) && (!edge || typeof edge === 'string')) {\n      return getOffsetFromDocument(el, edge);\n    }\n\n    // Otherwise assume that two element/document/window defintions were\n    // provided and calculate the offset from the second to the first element.\n    else {\n\n      var elemA = [].concat(el);\n      var elemB = [].concat(edge);\n      var offsetA = isPlainObject(el) ? el : getOffsetFromDocument(elemA[0], elemA[1]);\n      var offsetB = isPlainObject(edge) ? edge : getOffsetFromDocument(elemB[0], elemB[1]);\n\n      return {\n        left: offsetA.left - offsetB.left,\n        top: offsetA.top - offsetB.top\n      };\n\n    }\n\n  }\n\n  /**\n   * Returns an object containing the provided element's dimensions and offsets.\n   * This is basically a helper method for calculating an element's dimensions\n   * and offsets simultaneously. Mimics the native getBoundingClientRect method\n   * with the added bonus of allowing to provide the \"edge\" of the element.\n   *\n   * @example\n   * // Returns rect data for elemA (using the element's \"content\" layer in the\n   * // calculations) with the offset calculated from the document.\n   * mezr.offset(elemA, 'content');\n   *\n   * @example\n   * // Returns rect data for elemA (using the element's \"content\" layer in the\n   * // calculations) with the offset calculated from the window.\n   * mezr.rect([elemA, 'content'], window);\n   *\n   * @example\n   * // Returns rect data for elemA (using the element's \"padding\" layer in the\n   * // calculations) with the offset calculated from the elemB (\"margin\"\n   * // layer).\n   * mezr.rect([elemA, 'padding'], [elemB, 'margin']);\n   *\n   * @public\n   * @param {(Array|Document|Element|Rectangle|Window)} el\n   * @param {(Array|Document|Edge|Element|Rectangle|Window)} [edge='border']\n   *   - If this argument is a string it is considered to be an edge layer\n   *     definition for the first argument. Otherwise this is considered to be a\n   *     defintion of an element, document or window.\n   * @returns {Rectangle}\n   */\n  function getRect(el, edge) {\n\n    // Use default syntax if the element is not an array and the edge is\n    // undefined or a string.\n    if (!Array.isArray(el) && (!edge || typeof edge === 'string')) {\n      return getRectInternal(el, edge);\n    }\n\n    // Otherwise assume that two element/document/window defintions were\n    // provided and calculate the offset from the second to the first element.\n    else {\n\n      var elemA = [].concat(el);\n      var elemB = [].concat(edge);\n      var rect = isPlainObject(el) ? el : getRectInternal(elemA[0], elemA[1]);\n      var offsetFrom = isPlainObject(edge) ? edge : getOffsetFromDocument(elemB[0], elemB[1]);\n\n      rect.left = rect.left - offsetFrom.left;\n      rect.top = rect.top - offsetFrom.top;\n\n      return rect;\n\n    }\n\n  }\n\n  /**\n   * Returns the element's containing block, which is considered to be the\n   * closest ancestor element (or window, or document, or the target element\n   * itself) that the target element's positioning is relative to. In other\n   * words, containing block is the element the target element's CSS properties\n   * \"left\", \"right\", \"top\" and \"bottom\" are relative to. You should not confuse\n   * this with the native elem.offsetParent read-only property, which works in a\n   * similar fashion (and even identically in certain situations), but is really\n   * not the same thing (although the name might imply it).\n   *\n   * The logic:\n   * - Document is considered to be the root containing block of all elements\n   *   and the window. Getting the document's containing block will return null.\n   * - Static element does not have a containing block since setting values to\n   *   the \"left\", \"right\", \"top\" and \"bottom\" CSS properties does not have any\n   *   effect on the element's position. Thus, getting the containing block of a\n   *   static element will return null.\n   * - Relative element's containing block is always the element itself.\n   * - Fixed element's containing block is always the closest transformed\n   *   ancestor or window if the element does not have any transformed\n   *   ancestors. An exception is made for browsers which allow fixed elements\n   *   to bypass the W3C specification of transform rendering. In those browsers\n   *   fixed element's containing block is always the window.\n   * - Absolute element's containing block is the closest ancestor element that\n   *   is transformed or positioned (any element which is not static), or\n   *   document if no positioned or transformed ancestor is not found.\n   * - Sticky element is a special case since \"left\", \"right\", \"top\" and\n   *   \"bottom\" CSS properties do not always affect the element's position.\n   *   However, for consistency, the closest scrolling ancestor element is\n   *   always considered as sticky element's containing block, and if no\n   *   scrolling ancestor is found window is returned.\n   * - Root element and body element are considered as equals with all other\n   *   elements and are treated equally with all other elements.\n   *\n   * @example\n   * mezr.containingBlock(elemA);\n   *\n   * @example\n   * mezr.containingBlock(elemA, 'fixed');\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {String} [fakePosition]\n   *   - An optional argument which allows you to get the element's containing\n   *     block as if the element had this CSS position value applied. Using this\n   *     argument does not modify the element's true CSS position in any way,\n   *     it's only used for the calculations.\n   * @returns {?(Document|Element|Window)}\n   */\n  function getContainingBlock(el, fakePosition) {\n\n    var ret;\n    var scrollProps;\n    var parent;\n    var style;\n    var i;\n\n    // If we have document return null right away.\n    if (el === doc) {\n      return null;\n    }\n\n    // If we have window return document right away.\n    if (el === win) {\n      return doc;\n    }\n\n    // Now that we know we have an element in our hands, let's get it's\n    // position. Get element's current position value if a specific position is\n    // not provided.\n    var position = fakePosition || getStyle(el, 'position');\n\n    // Relative element's container is always the element itself.\n    if (position === 'relative') {\n      return el;\n    }\n\n    // If the element is fixed or absolute positioned.\n    else if (position === 'fixed' || position === 'absolute') {\n\n      // If the element is fixed and transforms leak fixed elements, always\n      // return window.\n      if (position === 'fixed' && settings.transformLeaksFixed) {\n        return win;\n      }\n\n      // Alrighty, so now fetch the element's parent (which is document for the\n      // root) and set it as the initial containing block. Fallback to null if\n      // everything else fails.\n      ret = el === root ? doc : el.parentElement || null;\n\n      // If element is fixed positioned: as long as the containing block is an\n      // element and is not transformed, try to get the element's parent element\n      // and fallback to document.\n      if (position === 'fixed') {\n        while (ret && ret !== doc && !isTransformed(ret)) {\n          ret = ret.parentElement || doc;\n        }\n        return ret === doc ? win : ret;\n      }\n\n      // If the element is absolute positioned: as long as the containing block\n      // is an element, is static and is not transformed, try to get the\n      // element's parent element and fallback to document.\n      else {\n        while (ret && ret !== doc && getStyle(ret, 'position') === 'static' && !isTransformed(ret)) {\n          ret = ret.parentElement || doc;\n        }\n        return ret;\n      }\n\n    }\n\n    // Sticky element's container is always the closest scrolling ancestor or\n    // window.\n    else if (position === 'sticky' || position === '-webkit-sticky') {\n\n      scrollProps = ['overflow', 'overflow-y', 'overflow-x'];\n      parent = el.parentNode;\n      el = null;\n\n      while (!el && parent && parent !== doc) {\n\n        for (i = 0; i < 3; i++) {\n          style = getStyle(parent, scrollProps[i]);\n          if (style === 'auto' || style === 'scroll') {\n            el = parent;\n            break;\n          }\n        }\n\n        if (!el) {\n          parent = parent.parentNode;\n        }\n\n      }\n\n      return el || win;\n\n    }\n\n    // If the element is static or an invalid position is provided always return\n    // null.\n    return null;\n\n  }\n\n  /**\n   * Calculate the distance between two elements or rectangles. Returns a\n   * number. If the elements/rectangles overlap the function returns -1. In\n   * other cases the function returns the distance in pixels (fractional)\n   * between the the two elements/rectangles.\n   *\n   * @example\n   * mezr.distance(elemA, elemB);\n   *\n   * @example\n   * mezr.distance([elemA, 'padding'], [elemB, 'margin']);\n\n   * @example\n   * mezr.distance(elemA, {left: 34, top: 56, width: 100, height: 200});\n   *\n   * @public\n   * @param {(Array|Document|Element|Window|Rectangle)} a\n   * @param {(Array|Document|Element|Window|Rectangle)} b\n   * @returns {Number}\n   */\n  function getDistance(a, b) {\n\n    var aRect = getSanitizedRect(a);\n    var bRect = getSanitizedRect(b);\n\n    return getIntersection(aRect, bRect) ? -1 : getDistanceBetweenRects(aRect, bRect);\n\n  }\n\n  /**\n   * Detect if all of the provided elements overlap and calculate the possible\n   * intersection area's dimensions and offsets. If the intersection area exists\n   * the function returns an object containing the intersection area's\n   * dimensions and offsets. Otherwise null is returned.\n   *\n   * @example\n   * mezr.intersection(elemA, elemB);\n   *\n   * @example\n   * mezr.intersection(elemA, [elemB, 'padding'], {\n   *   left: 0,\n   *   top: 10,\n   *   width: 100,\n   *   height: 200\n   * });\n   *\n   * @public\n   * @param {...(Array|Document|Element|Window|Rectangle)} el\n   * @returns {?Rectangle}\n   */\n  function getIntersectionMultiple() {\n\n    // Get the initial intersection of the first two items.\n    var intersection = getIntersection(arguments[0], arguments[1]);\n\n    // If there are more than two items.\n    if (arguments.length > 2) {\n\n      // Loop the arguments until the end or until the intersection is\n      // non-existent.\n      for (var i = 2; i < arguments.length; ++i) {\n        intersection = getIntersection(intersection, arguments[i]);\n        if (!intersection) {\n          break;\n        }\n      }\n\n    }\n\n    return intersection;\n\n  }\n\n  /**\n   * Calculate how much an element overflows another element per each side.\n   *\n   * @example\n   * mezr.overflow(elemA, elemB);\n   *\n   * @example\n   * mezr.overflow(elemA, [elemB, 'padding']);\n   *\n   * @public\n   * @param {(Array|Document|Element|Window|Rectangle)} elA\n   * @param {(Array|Document|Element|Window|Rectangle)} elB\n   * @returns {Overflow}\n   */\n  function getOverflow(elA, elB) {\n\n    var ret = getOverlap(elB, elA);\n\n    return {\n      left: -ret.left,\n      right: -ret.right,\n      top: -ret.top,\n      bottom: -ret.bottom\n    };\n\n  }\n\n  /**\n   * Calculate an element's position (left/top CSS properties) when positioned\n   * relative to another element, window or the document.\n   *\n   * @example\n   * var newElementPosition = mezr.place({\n   *   element: [elemA, 'content'],\n   *   target: [elemB, 'margin'],\n   *   position: 'left top center center',\n   *   offsetX: -5,\n   *   offsetY: '50%',\n   *   contain: {\n   *     within: [elemC, 'padding'],\n   *     onOverflow: {\n   *       left: 'forcepush',\n   *       right: 'push',\n   *       top: 'none',\n   *       bottom: 'push'\n   *     }\n   *   },\n   *   adjust: function (position, data) {\n   *     position.left -= 1;\n   *     position.top += 1;\n   *   }\n   * });\n   *\n   * @public\n   * @param {PlaceOptions} options\n   * @returns {PlaceData}\n   */\n  function getPlace(options) {\n\n    var ret = {};\n    var opts = mergeObjects([settings.placeDefaultOptions, options || {}]);\n    var position = typeof opts.position === 'string' ? opts.position.split(' ') : opts.position;\n    var eRect = getSanitizedRect(opts.element, true);\n    var tRect = getSanitizedRect(opts.target);\n    var isContainDefined = isPlainObject(opts.contain);\n    var container = isContainDefined && opts.contain.within;\n    var overflowAction = isContainDefined && getOverflowAction(opts.contain.onOverflow);\n    var overflowFixLeft = 0;\n    var overflowFixTop = 0;\n    var offsetX = opts.offsetX;\n    var offsetY = opts.offsetY;\n    var cRect;\n    var overlap;\n    var eCurrentOffset;\n\n    // Sanitize offsets and check for percentage values.\n    offsetX = typeof offsetX === 'string' && offsetX.indexOf('%') > -1 ? toFloat(offsetX) / 100 * eRect.width : toFloat(offsetX);\n    offsetY = typeof offsetY === 'string' && offsetY.indexOf('%') > -1 ? toFloat(offsetY) / 100 * eRect.height : toFloat(offsetY);\n\n    // Calculate element's new position (left/top coordinates).\n    ret.left = getPlacePosition(position[0], position[2], tRect.width, tRect.left, eRect.width, eRect.left, offsetX);\n    ret.top = getPlacePosition(position[1], position[3], tRect.height, tRect.top, eRect.height, eRect.top, offsetY);\n\n    // Update element offset data to match the newly calculated position.\n    eRect.left += ret.left;\n    eRect.top += ret.top;\n\n    // If container element and overflow action are defined, let's handle\n    // container's possible overflow.\n    if (container && overflowAction) {\n\n      // Get container rect and overlap data.\n      cRect = getSanitizedRect(container);\n      overlap = getOverlap(eRect, cRect);\n\n      // Handle horizontal overflow.\n      if (overlap.left < 0 || overlap.right < 0) {\n        overflowFixLeft = getPlaceOverflowPush(overflowAction, overlap);\n        ret.left += overflowFixLeft;\n      }\n\n      // Handle vertical overflow.\n      if (overlap.top < 0 || overlap.bottom < 0) {\n        overflowFixTop = getPlaceOverflowPush(overflowAction, overlap, 1);\n        ret.top += overflowFixTop;\n      }\n\n    }\n\n    if (typeof opts.adjust === 'function') {\n\n      // Update element's left and right rect data to account for the possible\n      // overflow correction.\n      if (overflowFixLeft !== 0) {\n        eRect.left += overflowFixLeft;\n        eRect.right = eRect.left + eRect.width;\n      }\n\n      // Update element's top and bottom rect data to account for the possible\n      // overflow correction.\n      if (overflowFixTop !== 0) {\n        eRect.top += overflowFixTop;\n        eRect.bottom = eRect.left + eRect.width;\n      }\n\n      // Get container rect.\n      cRect = container ? cRect || getSanitizedRect(container) : null;\n\n      // Get the element's current offset so we can calculate how much the\n      // element moved.\n      eCurrentOffset = isPlainObject(opts.element) ? opts.element : getOffsetFromDocument.apply(null, [].concat(opts.element));\n\n      // Calculate overlap data based on the new position.\n      overlap = cRect ? getOverlap(eRect, cRect) : null;\n\n      // Provide the final position hash as the first argument (which can be\n      // modified and it affects the return value of this method) and all the\n      // positioning data as the second argument.\n      opts.adjust(ret, {\n        elementRect: eRect,\n        targetRect: tRect,\n        containerRect: cRect,\n        shift: {\n          left: eRect.left - eCurrentOffset.left,\n          top: eRect.top - eCurrentOffset.top\n        },\n        overflow: !overlap ? null : {\n          left: -overlap.left,\n          right: -overlap.right,\n          top: -overlap.top,\n          bottom: -overlap.bottom\n        },\n        overflowCorrection: {\n          left: overflowFixLeft,\n          top: overflowFixTop\n        }\n      });\n\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Private helper functions\n   * ************************\n   */\n\n  /**\n   * Check if a value is a plain object.\n   *\n   * @private\n   * @param {*} val\n   * @returns {Boolean}\n   */\n  function isPlainObject(val) {\n\n    return typeof val === 'object' && Object.prototype.toString.call(val) === '[object Object]';\n\n  }\n\n  /**\n   * Returns the supported transform property's prefix, property name and style\n   * name or null if transforms are not supported.\n   *\n   * @private\n   * @returns {?Object}\n   */\n  function getSupportedTransform() {\n\n    var transforms = ['transform', 'WebkitTransform', 'MozTransform', 'OTransform', 'msTransform'];\n\n    for (var i = 0; i < transforms.length; i++) {\n      if (root.style[transforms[i]] !== undefined) {\n\n        var prop = transforms[i];\n        var prefix = prop.toLowerCase().split('transform')[0];\n\n        return {\n          prefix: prefix,\n          propName: prop,\n          styleName: prefix ? '-' + prefix + '-transform' : prop\n        };\n\n      }\n    }\n\n    return null;\n\n  }\n\n  /**\n   * Detects if transformed elements leak fixed elements. According W3C\n   * transform rendering spec a transformed element should contain even fixed\n   * elements. Meaning that fixed elements are positioned relative to the\n   * closest transformed ancestor element instead of window. However, not every\n   * browser follows the spec (IE and older Firefox), so we need to test it.\n   * https://www.w3.org/TR/css3-2d-transforms/#transform-rendering\n   *\n   * @private\n   * @returns {Boolean}\n   *   - Returns true if transformed elements leak fixed elements, false\n   *     otherwise.\n   */\n  function doesTransformLeakFixed() {\n\n    if (!settings.transform) {\n      return true;\n    }\n\n    var outer = doc.createElement('div');\n    var inner = doc.createElement('div');\n    var leftNotTransformed;\n    var leftTransformed;\n\n    setStyles(outer, {\n      display: 'block',\n      visibility: 'hidden',\n      position: 'absolute',\n      width: '1px',\n      height: '1px',\n      left: '1px',\n      top: '0',\n      margin: '0'\n    });\n\n    setStyles(inner, {\n      display: 'block',\n      position: 'fixed',\n      width: '1px',\n      height: '1px',\n      left: '0',\n      top: '0',\n      margin: '0'\n    });\n\n    outer.appendChild(inner);\n    body.appendChild(outer);\n    leftNotTransformed = inner.getBoundingClientRect().left;\n    outer.style[settings.transform.propName] = 'translateX(0)';\n    leftTransformed = inner.getBoundingClientRect().left;\n    body.removeChild(outer);\n\n    return leftTransformed === leftNotTransformed;\n\n  }\n\n  /**\n   * Returns true if element is transformed, false if not. In practice the\n   * element's display value must be anything else than \"none\" or \"inline\" as\n   * well as have a valid transform value applied in order to be counted as a\n   * transformed element.\n   *\n   * @private\n   * @param {Element} el\n   * @returns {Boolean}\n   */\n  function isTransformed(el) {\n\n    var transform = getStyle(el, settings.transform.styleName);\n    var display = getStyle(el, 'display');\n\n    return transform !== 'none' && display !== 'inline' && display !== 'none';\n\n  }\n\n  /**\n   * Customized parseFloat function which returns 0 instead of NaN.\n   *\n   * @private\n   * @param {Number|String} val\n   * @returns {Number}\n   */\n  function toFloat(val) {\n\n    return parseFloat(val) || 0;\n\n  }\n\n  /**\n   * Deep merge an array of objects into a new object.\n   *\n   * @private\n   * @param {Array} array\n   * @returns {Object}\n   */\n  function mergeObjects(array) {\n\n    var ret = {};\n    var propName;\n    var propVal;\n\n    for (var i = 0, len = array.length; i < len; i++) {\n      for (propName in array[i]) {\n        if (array[i].hasOwnProperty(propName)) {\n          propVal = array[i][propName];\n          ret[propName] = isPlainObject(propVal) ? mergeObjects([propVal]) :\n                          Array.isArray(propVal) ? propVal.slice() :\n                                                   propVal;\n        }\n      }\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Returns the computed value of an element's style property as a string.\n   *\n   * @private\n   * @param {Element} el\n   * @param {String} style\n   * @returns {String}\n   */\n  function getStyle(el, style) {\n\n    return win.getComputedStyle(el, null).getPropertyValue(style);\n\n  }\n\n  /**\n   * Returns the computed value of an element's style property transformed into\n   * a float value.\n   *\n   * @private\n   * @param {Element} el\n   * @param {String} style\n   * @returns {Number}\n   */\n  function getStyleAsFloat(el, style) {\n\n    return toFloat(getStyle(el, style));\n\n  }\n\n  /**\n   * Set inline styles to an element.\n   *\n   * @private\n   * @param {Element} el\n   * @param {Object} styles\n   */\n  function setStyles(el, styles) {\n\n    Object.keys(styles).forEach(function (styleName) {\n      el.style[styleName] = styles[styleName];\n    });\n\n  }\n\n  /**\n   * Calculates how much element overlaps another element from each side.\n   *\n   * @private\n   * @param {(Array|Document|Element|Window|Rectangle)} elA\n   * @param {(Array|Document|Element|Window|Rectangle)} elB\n   * @returns {Overlap}\n   */\n  function getOverlap(elA, elB) {\n\n    var aRect = getSanitizedRect(elA);\n    var bRect = getSanitizedRect(elB);\n\n    return {\n      left: aRect.left - bRect.left,\n      right: (bRect.left + bRect.width) - (aRect.left + aRect.width),\n      top: aRect.top - bRect.top,\n      bottom: (bRect.top + bRect.height) - (aRect.top + aRect.height)\n    };\n\n  }\n\n  /**\n   * Detect if two elements overlap and calculate the possible intersection\n   * area's dimensions and offsets. If the intersection area exists the function\n   * returns an object containing the intersection area's dimensions and\n   * offsets. Otherwise null is returned.\n   *\n   * @private\n   * @param {(Array|Document|Element|Window|Rectangle)} elA\n   * @param {(Array|Document|Element|Window|Rectangle)} elB\n   * @returns {?RectangleExtended}\n   */\n  function getIntersection(elA, elB) {\n\n    var ret = {};\n    var aRect = getSanitizedRect(elA);\n    var bRect = getSanitizedRect(elB);\n    var overlap = getOverlap(aRect, bRect);\n    var intWidth = max(aRect.width + min(overlap.left, 0) + min(overlap.right, 0), 0);\n    var intHeight = max(aRect.height + min(overlap.top, 0) + min(overlap.bottom, 0), 0);\n    var hasIntersection = intWidth > 0 && intHeight > 0;\n\n    if (hasIntersection) {\n      ret.width = intWidth;\n      ret.height = intHeight;\n      ret.left = aRect.left + abs(min(overlap.left, 0));\n      ret.top = aRect.top + abs(min(overlap.top, 0));\n      ret.right = ret.left + ret.width;\n      ret.bottom = ret.top + ret.height;\n    }\n\n    return hasIntersection ? ret : null;\n\n  }\n\n  /**\n   * Calculates the distance between two points in 2D space.\n   *\n   * @private\n   * @param {Number} aLeft\n   * @param {Number} aTop\n   * @param {Number} bLeft\n   * @param {Number} bTop\n   * @returns {Number}\n   */\n  function getDistanceBetweenPoints(aLeft, aTop, bLeft, bTop) {\n\n    return Math.sqrt(Math.pow(bLeft - aLeft, 2) + Math.pow(bTop - aTop, 2));\n\n  }\n\n  /**\n   * Calculates the distance between two unrotated rectangles in 2D space. This\n   * function assumes that the rectangles do not intersect.\n   *\n   * @private\n   * @param {Rectangle} rectA\n   * @param {Rectangle} rectB\n   * @returns {Number}\n   */\n  function getDistanceBetweenRects(rectA, rectB) {\n\n    var ret = 0;\n    var aLeft = rectA.left;\n    var aRight = aLeft + rectA.width;\n    var aTop = rectA.top;\n    var aBottom = aTop + rectA.height;\n    var bLeft = rectB.left;\n    var bRight = bLeft + rectB.width;\n    var bTop = rectB.top;\n    var bBottom = bTop + rectB.height;\n\n    // Calculate shortest corner distance\n    if ((bLeft > aRight || bRight < aLeft) && (bTop > aBottom || bBottom < aTop)) {\n      if (bLeft > aRight) {\n        ret = bBottom < aTop ? getDistanceBetweenPoints(aRight, aTop, bLeft, bBottom) : getDistanceBetweenPoints(aRight, aBottom, bLeft, bTop);\n      }\n      else {\n        ret = bBottom < aTop ? getDistanceBetweenPoints(aLeft, aTop, bRight, bBottom) : getDistanceBetweenPoints(aLeft, aBottom, bRight, bTop);\n      }\n    }\n\n    // Calculate shortest edge distance\n    else {\n      ret = bBottom < aTop ? aTop - bBottom :\n            bLeft > aRight ? bLeft - aRight :\n            bTop > aBottom ? bTop - aBottom :\n            aLeft - bRight;\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Returns the height/width of an element in pixels. The function also accepts\n   * the window object (for obtaining the viewport dimensions) and the document\n   * object (for obtaining the dimensions of the document) in place of element.\n   * Note that this function considers root element's scrollbars as the\n   * document's and window's scrollbars also. Since the root element's\n   * scrollbars are always stuck on the right/bottom edge of the window (even if\n   * you specify width and/or height to root element) they are generally\n   * referred to as viewport scrollbars in the docs. Also note that only\n   * positive margins are included in the result when includeMargin argument is\n   * true.\n   *\n   * @private\n   * @param {String} dimension\n   *   - Accepts \"width\" or \"height\".\n   * @param {(Document|Element|Window)} el\n   * @param {Boolean} [includePadding=false]\n   * @param {Boolean} [includeScrollbar=false]\n   * @param {Boolean} [includeBorder=false]\n   * @param {Boolean} [includeMargin=false]\n   * @returns {Number}\n   *   - The return value may be fractional when calculating the width of an\n   *     element. For window and document objects the value is always an integer\n   *     though.\n   */\n  function getDimension(dimension, el, includePadding, includeScrollbar, includeBorder, includeMargin) {\n\n    var ret;\n    var isHeight = dimension === 'height';\n    var dimensionCapitalized = isHeight ? 'Height' : 'Width';\n    var innerDimension = 'inner' + dimensionCapitalized;\n    var clientDimension = 'client' + dimensionCapitalized;\n    var scrollDimension = 'scroll' + dimensionCapitalized;\n    var sbSize = 0;\n    var edgeA;\n    var edgeB;\n    var borderA;\n    var borderB;\n    var marginA;\n    var marginB;\n\n    if (el.self === win.self) {\n\n      ret = includeScrollbar ? win[innerDimension] : root[clientDimension];\n\n    }\n    else if (el === doc) {\n\n      if (includeScrollbar) {\n        sbSize = win[innerDimension] - root[clientDimension];\n        ret = max(root[scrollDimension] + sbSize, body[scrollDimension] + sbSize, win[innerDimension]);\n      }\n      else {\n        ret = max(root[scrollDimension], body[scrollDimension], root[clientDimension]);\n      }\n\n    }\n    else {\n\n      edgeA = isHeight ? 'top' : 'left';\n      edgeB = isHeight ? 'bottom' : 'right';\n      ret = (tempBCR || el.getBoundingClientRect())[dimension];\n\n      if (!includeScrollbar) {\n\n        if (el === root) {\n          sbSize = win[innerDimension] - root[clientDimension];\n        }\n        else if (unscrollableDisplayValues.indexOf(getStyle(el, 'display')) < 0) {\n          borderA = getStyleAsFloat(el, 'border-' + edgeA + '-width');\n          borderB = getStyleAsFloat(el, 'border-' + edgeB + '-width');\n          sbSize = Math.round(ret) - (el[clientDimension] + borderA + borderB);\n        }\n\n        ret -= sbSize > 0 ? sbSize : 0;\n\n      }\n\n      if (!includePadding) {\n        ret -= getStyleAsFloat(el, 'padding-' + edgeA);\n        ret -= getStyleAsFloat(el, 'padding-' + edgeB);\n      }\n\n      if (!includeBorder) {\n        ret -= borderA !== undefined ? borderA : getStyleAsFloat(el, 'border-' + edgeA + '-width');\n        ret -= borderB !== undefined ? borderB : getStyleAsFloat(el, 'border-' + edgeB + '-width');\n      }\n\n      if (includeMargin) {\n        marginA = getStyleAsFloat(el, 'margin-' + edgeA);\n        marginB = getStyleAsFloat(el, 'margin-' + edgeB);\n        ret += marginA > 0 ? marginA : 0;\n        ret += marginB > 0 ? marginB : 0;\n      }\n\n    }\n\n    return ret > 0 ? ret : 0;\n\n  }\n\n  /**\n   * Returns the element's (or window's) document offset, which in practice\n   * means the vertical and horizontal distance between the element's northwest\n   * corner and the document's northwest corner.\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} [edge='border']\n   * @returns {Offset}\n   */\n  function getOffsetFromDocument(el, edge) {\n\n    var ret = {\n      left: 0,\n      top: 0\n    };\n\n    // Document's offsets are always 0.\n    if (el === doc) {\n      return ret;\n    }\n\n    // Add viewport's scroll left/top to the respective offsets.\n    ret.left = win.pageXOffset || 0;\n    ret.top = win.pageYOffset || 0;\n\n    // Window's offsets are the viewport's scroll left/top values.\n    if (el.self === win.self) {\n      return ret;\n    }\n\n    // Now we know we are calculating an element's offsets so let's first get\n    // the element's bounding client rect. If it is not cached, then just fetch\n    // it.\n    var gbcr = tempBCR || el.getBoundingClientRect();\n\n    // Add bounding client rect's left/top values to the offsets.\n    ret.left += gbcr.left;\n    ret.top += gbcr.top;\n\n    // Sanitize edge.\n    edge = edge && edges[edge] || 4;\n\n    // Exclude element's positive margin size from the offset if needed.\n    if (edge === 5) {\n      var marginLeft = getStyleAsFloat(el, 'margin-left');\n      var marginTop = getStyleAsFloat(el, 'margin-top');\n      ret.left -= marginLeft > 0 ? marginLeft : 0;\n      ret.top -= marginTop > 0 ? marginTop : 0;\n    }\n\n    // Include element's border size to the offset if needed.\n    if (edge < 4) {\n      ret.left += getStyleAsFloat(el, 'border-left-width');\n      ret.top += getStyleAsFloat(el, 'border-top-width');\n    }\n\n    // Include element's padding size to the offset if needed.\n    if (edge === 1) {\n      ret.left += getStyleAsFloat(el, 'padding-left');\n      ret.top += getStyleAsFloat(el, 'padding-top');\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Returns an object containing the provided element's dimensions and offsets.\n   * This is basically just a wrapper for the getRectInternal function which\n   * does some argument normalization before doing the actal calculations. Used\n   * only internally.\n   *\n   * @private\n   * @param {(Array|Document|Element|Window|Rectangle)} el\n   * @param {Boolean} [useStaticOffset=false]\n   * @returns {?Rectangle}\n   */\n  function getSanitizedRect(el, useStaticOffset) {\n\n    // Can't have an empty value.\n    if (!el) {\n      return null;\n    }\n\n    // Let's assume that plain objects are static rectangle definitions.\n    if (isPlainObject(el)) {\n      return el;\n    }\n\n    // We don't know for sure if the provided element is defined with an edge\n    // layer (array syntax) or not. So let's play it safe an normalize the value\n    // to an array.\n    el = [].concat(el);\n\n    return getRectInternal(el[0], el[1], useStaticOffset);\n\n  }\n\n  /**\n   * Returns an object containing the provided element's dimensions and offsets.\n   * This is basically a helper method for calculating an element's dimensions\n   * and offsets simultaneously. Mimics the native getBoundingClientRect method\n   * with the added bonus of allowing to provide the \"edge\" of the element.\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} [edge='border']\n   * @param {Boolean} [useStaticOffset=false]\n   * @returns {Rectangle}\n   */\n  function getRectInternal(el, edge, useStaticOffset) {\n\n    var isElem = el !== doc && el.self !== win.self;\n    var rect;\n\n    // Sanitize edge.\n    edge = edge || 'border';\n\n    // If static offset is required we have to get it before temporary bounding\n    // client rect is cached, since it might need to get the offset of another\n    // element than the cached one.\n    if (useStaticOffset) {\n      rect = getStaticOffset(el, edge);\n    }\n\n    // Cache element's bounding client rect.\n    if (isElem) {\n      tempBCR = el.getBoundingClientRect();\n    }\n\n    // If static offset is not required we know for sure that the temporary\n    // bounding client rect is the same element we need to get offset for.\n    if (!useStaticOffset) {\n      rect = getOffsetFromDocument(el, edge);\n    }\n\n    // Get element's width and height.\n    rect.width = getWidth(el, edge);\n    rect.height = getHeight(el, edge);\n\n    // Calculate element's bottom and right.\n    rect.bottom = rect.top + rect.height;\n    rect.right = rect.left + rect.width;\n\n    // Nullify temporary bounding client rect cache.\n    if (isElem) {\n      tempBCR = null;\n    }\n\n    return rect;\n\n  }\n\n  /**\n   * Returns an element's static offset which in this case means the element's\n   * offset in a state where the element's left and top CSS properties are set\n   * to 0.\n   *\n   * @private\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} edge\n   * @returns {Offset}\n   */\n  function getStaticOffset(el, edge) {\n\n    // Sanitize edge.\n    edge = edge || 'border';\n\n    // For window and document just return normal offset.\n    if (el === win || el === doc) {\n      return getOffsetFromDocument(el, edge);\n    }\n\n    var position = getStyle(el, 'position');\n    var offset = position === 'absolute' || position === 'fixed' ? getOffsetFromDocument(getContainingBlock(el) || doc, 'padding') : getOffsetFromDocument(el, edge);\n\n    if (position === 'relative') {\n\n      var left = getStyle(el, 'left');\n      var right = getStyle(el, 'right');\n      var top = getStyle(el, 'top');\n      var bottom = getStyle(el, 'bottom');\n\n      if (left !== 'auto' || right !== 'auto') {\n        offset.left -= left === 'auto' ? -toFloat(right) : toFloat(left);\n      }\n\n      if (top !== 'auto' || bottom !== 'auto') {\n        offset.top -= top === 'auto' ? -toFloat(bottom) : toFloat(top);\n      }\n\n    }\n    else if (position === 'absolute' || position === 'fixed') {\n\n      // Get edge number.\n      edge = edges[edge];\n\n      // Get left and top margins.\n      var marginLeft = getStyleAsFloat(el, 'margin-left');\n      var marginTop = getStyleAsFloat(el, 'margin-top');\n\n      // If edge is \"margin\" remove negative left/top margins from offset to\n      // account for their effect on position.\n      if (edge === 5) {\n        offset.left -= abs(min(marginLeft, 0));\n        offset.top -= abs(min(marginTop, 0));\n      }\n\n      // If edge is \"border\" or smaller add positive left/top margins and remove\n      // negative left/top margins from offset to account for their effect on\n      // position.\n      if (edge < 5) {\n        offset.left += marginLeft;\n        offset.top += marginTop;\n      }\n\n      // If edge is \"scroll\" or smaller add left/top borders to offset to\n      // account for their effect on position.\n      if (edge < 4) {\n        offset.left += getStyleAsFloat(el, 'border-left-width');\n        offset.top += getStyleAsFloat(el, 'border-top-width');\n      }\n\n      // If edge is \"content\" add left/top paddings to offset to account for\n      // their effect on position.\n      if (edge === 1) {\n        offset.left += getStyleAsFloat(el, 'padding-left');\n        offset.top += getStyleAsFloat(el, 'padding-top');\n      }\n\n    }\n\n    return offset;\n\n  }\n\n  /**\n   * Returns the horizontal or vertical base position of an element relative to\n   * the target element. In other words, this function returns the left and top\n   * CSS values which should be set as to the target element in order to\n   * position it according to the desired position.\n   *\n   * @private\n   * @param {String} elementPosition\n   *   - Element's position: \"left\", \"right\", \"top\", \"bottom\" or \"center\".\n   * @param {String} targetPosition\n   *   - Target's position: \"left\", \"right\", \"top\", \"bottom\" or \"center\".\n   * @param {Number} targetSize\n   *   - Target's width/height in pixels.\n   * @param {Number} targetOffset\n   *   - Target's left/top offset in pixels.\n   * @param {Number} elementSize\n   *   - Element's width/height in pixels.\n   * @param {Number} elementNwOffset\n   *   - Element's left/top northwest offset in pixels.\n   * @param {Number} extraOffset\n   *   - Additional left/top offset in pixels.\n   * @returns {Number}\n   */\n  function getPlacePosition(elementPosition, targetPosition, targetSize, targetOffset, elementSize, elementNwOffset, extraOffset) {\n\n    var placement = elementPosition.charAt(0) + targetPosition.charAt(0);\n    var northwestPoint = targetOffset + extraOffset - elementNwOffset;\n\n    return placement === 'll' || placement === 'tt' ? northwestPoint :\n           placement === 'lc' || placement === 'tc' ? northwestPoint + (targetSize / 2) :\n           placement === 'lr' || placement === 'tb' ? northwestPoint + targetSize :\n           placement === 'cl' || placement === 'ct' ? northwestPoint - (elementSize / 2) :\n           placement === 'cr' || placement === 'cb' ? northwestPoint + targetSize - (elementSize / 2) :\n           placement === 'rl' || placement === 'bt' ? northwestPoint - elementSize :\n           placement === 'rc' || placement === 'bc' ? northwestPoint - elementSize + (targetSize / 2) :\n           placement === 'rr' || placement === 'bb' ? northwestPoint - elementSize + targetSize :\n                                                      northwestPoint + (targetSize / 2) - (elementSize / 2);\n\n  }\n\n  /**\n   * Calculates the distance in pixels that the element needs to be moved in\n   * order to be aligned correctly if the target element overlaps the container.\n   *\n   * @private\n   * @param {OverflowConfig} overflowConfig\n   * @param {Overlap} targetOverlap\n   * @param {Boolean} isVertical\n   * @returns {Number}\n   */\n  function getPlaceOverflowPush(overflowConfig, targetOverlap, isVertical) {\n\n    var ret = 0;\n    var push = 'push';\n    var forcePush = 'forcepush';\n    var sideA = isVertical ? 'top' : 'left';\n    var sideB = isVertical ? 'bottom' : 'right';\n    var sideAConfig = overflowConfig[sideA];\n    var sideBConfig = overflowConfig[sideB];\n    var sideAOverlap = targetOverlap[sideA];\n    var sideBOverlap = targetOverlap[sideB];\n    var sizeDifference = sideAOverlap + sideBOverlap;\n\n    // If pushing is needed from both sides.\n    if ((sideAConfig === push || sideAConfig === forcePush) && (sideBConfig === push || sideBConfig === forcePush) && (sideAOverlap < 0 || sideBOverlap < 0)) {\n\n      // Do push correction from opposite sides with equal force.\n      if (sideAOverlap < sideBOverlap) {\n        ret -= sizeDifference < 0 ? sideAOverlap + abs(sizeDifference / 2) : sideAOverlap;\n      }\n\n      // Do push correction from opposite sides with equal force.\n      if (sideBOverlap < sideAOverlap) {\n        ret += sizeDifference < 0 ? sideBOverlap + abs(sizeDifference / 2) : sideBOverlap;\n      }\n\n      // Update overlap data.\n      sideAOverlap += ret;\n      sideBOverlap -= ret;\n\n      // Check if left/top side forced push correction is needed.\n      if (sideAConfig === forcePush && sideBConfig !== forcePush && sideAOverlap < 0) {\n        ret -= sideAOverlap;\n      }\n\n      // Check if right/top side forced push correction is needed.\n      if (sideBConfig === forcePush && sideAConfig !== forcePush && sideBOverlap < 0) {\n        ret += sideBOverlap;\n      }\n\n    }\n\n    // Check if pushing is needed from left or top side only.\n    else if ((sideAConfig === forcePush || sideAConfig === push) && sideAOverlap < 0) {\n      ret -= sideAOverlap;\n    }\n\n    // Check if pushing is needed from right or bottom side only.\n    else if ((sideBConfig === forcePush || sideBConfig === push) && sideBOverlap < 0) {\n      ret += sideBOverlap;\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Sanitize contain.onOverflow option of .place() method.\n   *\n   * @private\n   * @param {OverflowConfig} overflowConfig\n   * @returns {?overflowConfigSanitized}\n   */\n  function getOverflowAction(overflowConfig) {\n\n    var actionType = typeof overflowConfig;\n    var left = 'none';\n    var right = 'none';\n    var top = 'none';\n    var bottom = 'none';\n\n    // onOverflow string value is always used for all sides.\n    if (actionType === 'string') {\n      left = right = top = bottom = overflowConfig;\n    }\n\n    // onOverflow object value can have properties that present a side\n    // (left/right/top/bottom) or an axis (x/y). Always try to use the side\n    // value first and then fallback to axis value. If all else fails fallback\n    // to \"none\".\n    else if (actionType === 'object') {\n      left = overflowConfig.left || overflowConfig.x || left;\n      right = overflowConfig.right || overflowConfig.x || right;\n      top = overflowConfig.top || overflowConfig.y || top;\n      bottom = overflowConfig.bottom || overflowConfig.y || bottom;\n    }\n\n    // If one side (or more) has a value other than \"none\" we know that the\n    // contain option might have an effect on the positioning.\n    if (left !== 'none' || right !== 'none' || top !== 'none' || bottom !== 'none') {\n      return {\n        left: left,\n        right: right,\n        top: top,\n        bottom: bottom\n      };\n    }\n\n    return null;\n\n  }\n\n  /**\n   * Custom type definitions\n   * ***********************\n   */\n\n  /**\n   * The browser's window object.\n   *\n   * @typedef {Object} Window\n   */\n\n  /**\n   * The document contained in browser's window object.\n   *\n   * @typedef {Object} Document\n   */\n\n  /**\n   * Any HTML element including root and body elements.\n   *\n   * @typedef {Object} Element\n   */\n\n  /**\n   * The name of an element's box model edge which allows you to decide which\n   * areas of the element you want to include in the calculations. Valid edge\n   * values are \"content\", \"padding\", \"scroll\", \"border\" and \"margin\", in that\n   * specific order. Note that \"scroll\" is not a valid element edge accroding to\n   * W3C spec, but it is used here to define whether or not the scrollbar's size\n   * should be included in the calculations. For window and document objects\n   * this argument behaves a bit differently since they cannot have any\n   * paddings, borders or margins. Only \"content\" (without vertical scrollbar’s\n   * width) and \"scroll\" (with vertical scrollbar’s width) are effective values.\n   * \"padding\" is normalized to \"content\" while \"border\" and \"margin\" are\n   * normalized to \"scroll\".\n   *\n   * @typedef {String} Edge\n   */\n\n  /**\n   * @typedef {Object} Rectangle\n   * @property {Number} left\n   *   - Element's horizontal distance from the left edge of the document.\n   * @property {Number} top\n   *   - Element's vertical distance from the top edge of the document.\n   * @property {Number} height\n   *   - Element's height.\n   * @property {Number} width\n   *   - Element's width.\n   */\n\n  /**\n   * @typedef {Object} RectangleExtended\n   * @property {Number} left\n   *   - Element's horizontal distance from the left edge of the document.\n   * @property {Number} right\n   *   - Element's horizontal distance from the left edge of the document plus\n   *     width.\n   * @property {Number} top\n   *   - Element's vertical distance from the top edge of the document\n   * @property {Number} bottom\n   *   - Element's vertical distance from the top edge of the document plus\n   *     height.\n   * @property {Number} height\n   *   - Element's height.\n   * @property {Number} width\n   *   - Element's width.\n   */\n\n  /**\n   * @typedef {Object} Offset\n   * @property {Number} left\n   *   - Element's horizontal distance from the left edge of the document,\n   *     window or other element.\n   * @property {Number} top\n   *   - Element's vertical distance from the top edge of the document, window,\n   *     or other element.\n   */\n\n  /**\n   * @typedef {Object} Overlap\n   * @property {Number} left\n   * @property {Number} top\n   * @property {Number} right\n   * @property {Number} bottom\n   */\n\n  /**\n   * @typedef {Object} Overflow\n   * @property {Number} left\n   * @property {Number} top\n   * @property {Number} right\n   * @property {Number} bottom\n   */\n\n  /**\n   * @typedef {Object} PlaceOptions\n   * @param {(Array|Document|Element|Window|Rectangle)} element\n   * @property {(Array|Document|Element|Window|Rectangle)} target\n   * @property {PlaceOptionsPosition} [position='left top left top']\n   * @property {Number} [offsetX=0]\n   * @property {Number} [offsetY=0]\n   * @property {?PlaceOptionsContainment} [contain=null]\n   */\n\n  /**\n   * Raw positioning data for position option of .place() method.\n   * String syntax: \"elemX elemY targetX targetY\".\n   * Array syntax: [\"elemX\", \"elemY\", \"targetX\", \"targetY\"].\n   * Possible values for elemX and targetX: \"left\", \"center\", \"right\".\n   * Possible values for elemY and targetY: \"top\", \"center\", \"bottom\".\n   *\n   * @typedef {(Array|String)} PlaceOptionsPosition\n   */\n\n  /**\n   * All properties accepts the following values: \"push\", \"forcepush\" and\n   * \"none\".\n   *\n   * @typedef {Object} PlaceOptionsContainment\n   * @property {?(Array|Document|Element|Window|Rectangle)} within\n   * @property {?(OverflowConfig|String)} onOverflow\n   */\n\n  /**\n   * All properties accepts the following values: \"push\", \"forcepush\" and\n   * \"none\". The properties left, right, top and bottom are used to define the\n   * overflow action that should be called when the positioned element overflows\n   * the container element from the respective side. Alternatively you can also\n   * use the properties x and y to define the overflow action per axis. If you\n   * mix side overflow properties with axis overflow properties remember that\n   * the side configuration overwrites the axis configuration.\n   *\n   * @typedef {Object} OverflowConfig\n   * @property {String} [left='none']\n   * @property {String} [right='none']\n   * @property {String} [top='none']\n   * @property {String} [bottom='none']\n   * @property {String} [x='none']\n   * @property {String} [y='none']\n   */\n\n  /**\n   * A sanitized configuration data object for contain.onOverflow option of\n   * .place() method.\n   *\n   * @typedef {Object} OverflowConfigSanitized\n   * @property {String} left\n   * @property {String} right\n   * @property {String} top\n   * @property {String} bottom\n   */\n\n  /**\n   * @typedef {Object} PlaceData\n   * @property {Number} left\n   *   - Target element's new left position.\n   * @property {Number} top\n   *   - Target element's new top position.\n   */\n\n  // Name and return the public methods.\n  return {\n    width: getWidth,\n    height: getHeight,\n    offset: getOffset,\n    rect: getRect,\n    containingBlock: getContainingBlock,\n    distance: getDistance,\n    intersection: getIntersectionMultiple,\n    overflow: getOverflow,\n    place: getPlace,\n    _settings: settings\n  };\n\n}));\n"],"sourceRoot":""}