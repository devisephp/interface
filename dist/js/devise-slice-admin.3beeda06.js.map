{"version":3,"sources":["webpack:///./node_modules/query-string/node_modules/strict-uri-encode/index.js","webpack:///./node_modules/query-string/index.js","webpack:///./node_modules/decode-uri-component/index.js","webpack:///./node_modules/split-on-first/index.js","webpack:///./node_modules/mezr/mezr.js"],"names":["module","exports","str","encodeURIComponent","replace","x","charCodeAt","toString","toUpperCase","strictUriEncode","decodeComponent","splitOnFirst","isNullOrUndefined","value","undefined","encoderForArrayFormat","options","arrayFormat","key","result","index","length","skipNull","skipEmptyString","encode","join","arrayFormatSeparator","parserForArrayFormat","accumulator","exec","concat","isArray","split","indexOf","newValue","map","item","decode","validateArrayFormatSeparator","TypeError","strict","keysSorter","input","Array","sort","Object","keys","a","b","Number","removeHash","hashStart","slice","getHash","url","hash","extract","queryStart","parseValue","parseNumbers","isNaN","trim","parseBooleans","toLowerCase","parse","assign","formatter","ret","create","param","includes","k","reduce","Boolean","stringify","object","shouldFilter","objectCopy","filter","parseUrl","query","parseFragmentIdentifier","fragmentIdentifier","stringifyUrl","queryFromUrl","parsedQueryFromUrl","queryString","token","singleMatcher","RegExp","multiMatcher","decodeComponents","components","decodeURIComponent","err","left","right","prototype","call","tokens","match","i","customDecodeURIComponent","replaceMap","entries","encodedURI","string","separator","separatorIndex","global","factory","this","win","document","self","defaultView","window","doc","root","documentElement","body","Error","tempBCR","abs","Math","max","min","edges","content","padding","scroll","border","margin","unscrollableDisplayValues","settings","getWidth","el","edge","getDimension","getHeight","getOffset","elemA","elemB","offsetA","isPlainObject","getOffsetFromDocument","offsetB","top","getRect","rect","getRectInternal","offsetFrom","getContainingBlock","fakePosition","scrollProps","parent","style","position","getStyle","transformLeaksFixed","parentElement","isTransformed","parentNode","getDistance","aRect","getSanitizedRect","bRect","getIntersection","getDistanceBetweenRects","getIntersectionMultiple","intersection","arguments","getOverflow","elA","elB","getOverlap","bottom","getPlace","cRect","overlap","eCurrentOffset","opts","mergeObjects","placeDefaultOptions","eRect","element","tRect","target","isContainDefined","contain","container","within","overflowAction","getOverflowAction","onOverflow","overflowFixLeft","overflowFixTop","offsetX","offsetY","toFloat","width","height","getPlacePosition","getPlaceOverflowPush","adjust","apply","elementRect","targetRect","containerRect","shift","overflow","overflowCorrection","val","getSupportedTransform","transforms","prop","prefix","propName","styleName","doesTransformLeakFixed","transform","leftNotTransformed","leftTransformed","outer","createElement","inner","setStyles","display","visibility","appendChild","getBoundingClientRect","removeChild","parseFloat","array","propVal","len","hasOwnProperty","getComputedStyle","getPropertyValue","getStyleAsFloat","styles","forEach","intWidth","intHeight","hasIntersection","getDistanceBetweenPoints","aLeft","aTop","bLeft","bTop","sqrt","pow","rectA","rectB","aRight","aBottom","bRight","bBottom","dimension","includePadding","includeScrollbar","includeBorder","includeMargin","edgeA","edgeB","borderA","borderB","marginA","marginB","isHeight","dimensionCapitalized","innerDimension","clientDimension","scrollDimension","sbSize","round","pageXOffset","pageYOffset","gbcr","marginLeft","marginTop","useStaticOffset","isElem","getStaticOffset","offset","elementPosition","targetPosition","targetSize","targetOffset","elementSize","elementNwOffset","extraOffset","placement","charAt","northwestPoint","overflowConfig","targetOverlap","isVertical","push","forcePush","sideA","sideB","sideAConfig","sideBConfig","sideAOverlap","sideBOverlap","sizeDifference","actionType","y","containingBlock","distance","place","_settings"],"mappings":"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","file":"js/devise-slice-admin.3beeda06.js","sourcesContent":["'use strict';\nmodule.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);\n","'use strict';\nconst strictUriEncode = require('strict-uri-encode');\nconst decodeComponent = require('decode-uri-component');\nconst splitOnFirst = require('split-on-first');\n\nconst isNullOrUndefined = value => value === null || value === undefined;\n\nfunction encoderForArrayFormat(options) {\n\tswitch (options.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tconst index = result.length;\n\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), '[', index, ']'].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [\n\t\t\t\t\t...result,\n\t\t\t\t\t[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')\n\t\t\t\t];\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), '[]'].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), '[]=', encode(value, options)].join('')];\n\t\t\t};\n\n\t\tcase 'comma':\n\t\tcase 'separator':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (value === null || value === undefined || value.length === 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (result.length === 0) {\n\t\t\t\t\treturn [[encode(key, options), '=', encode(value, options)].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [[result, encode(value, options)].join(options.arrayFormatSeparator)];\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, encode(key, options)];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), '=', encode(value, options)].join('')];\n\t\t\t};\n\t}\n}\n\nfunction parserForArrayFormat(options) {\n\tlet result;\n\n\tswitch (options.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /\\[(\\d*)\\]$/.exec(key);\n\n\t\t\t\tkey = key.replace(/\\[\\d*\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = {};\n\t\t\t\t}\n\n\t\t\t\taccumulator[key][result[1]] = value;\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /(\\[\\])$/.exec(key);\n\t\t\t\tkey = key.replace(/\\[\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\n\t\tcase 'comma':\n\t\tcase 'separator':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tconst isArray = typeof value === 'string' && value.split('').indexOf(options.arrayFormatSeparator) > -1;\n\t\t\t\tconst newValue = isArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);\n\t\t\t\taccumulator[key] = newValue;\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\t}\n}\n\nfunction validateArrayFormatSeparator(value) {\n\tif (typeof value !== 'string' || value.length !== 1) {\n\t\tthrow new TypeError('arrayFormatSeparator must be single character string');\n\t}\n}\n\nfunction encode(value, options) {\n\tif (options.encode) {\n\t\treturn options.strict ? strictUriEncode(value) : encodeURIComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction decode(value, options) {\n\tif (options.decode) {\n\t\treturn decodeComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction keysSorter(input) {\n\tif (Array.isArray(input)) {\n\t\treturn input.sort();\n\t}\n\n\tif (typeof input === 'object') {\n\t\treturn keysSorter(Object.keys(input))\n\t\t\t.sort((a, b) => Number(a) - Number(b))\n\t\t\t.map(key => input[key]);\n\t}\n\n\treturn input;\n}\n\nfunction removeHash(input) {\n\tconst hashStart = input.indexOf('#');\n\tif (hashStart !== -1) {\n\t\tinput = input.slice(0, hashStart);\n\t}\n\n\treturn input;\n}\n\nfunction getHash(url) {\n\tlet hash = '';\n\tconst hashStart = url.indexOf('#');\n\tif (hashStart !== -1) {\n\t\thash = url.slice(hashStart);\n\t}\n\n\treturn hash;\n}\n\nfunction extract(input) {\n\tinput = removeHash(input);\n\tconst queryStart = input.indexOf('?');\n\tif (queryStart === -1) {\n\t\treturn '';\n\t}\n\n\treturn input.slice(queryStart + 1);\n}\n\nfunction parseValue(value, options) {\n\tif (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {\n\t\tvalue = Number(value);\n\t} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {\n\t\tvalue = value.toLowerCase() === 'true';\n\t}\n\n\treturn value;\n}\n\nfunction parse(input, options) {\n\toptions = Object.assign({\n\t\tdecode: true,\n\t\tsort: true,\n\t\tarrayFormat: 'none',\n\t\tarrayFormatSeparator: ',',\n\t\tparseNumbers: false,\n\t\tparseBooleans: false\n\t}, options);\n\n\tvalidateArrayFormatSeparator(options.arrayFormatSeparator);\n\n\tconst formatter = parserForArrayFormat(options);\n\n\t// Create an object with no prototype\n\tconst ret = Object.create(null);\n\n\tif (typeof input !== 'string') {\n\t\treturn ret;\n\t}\n\n\tinput = input.trim().replace(/^[?#&]/, '');\n\n\tif (!input) {\n\t\treturn ret;\n\t}\n\n\tfor (const param of input.split('&')) {\n\t\tlet [key, value] = splitOnFirst(options.decode ? param.replace(/\\+/g, ' ') : param, '=');\n\n\t\t// Missing `=` should be `null`:\n\t\t// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\t\tvalue = value === undefined ? null : ['comma', 'separator'].includes(options.arrayFormat) ? value : decode(value, options);\n\t\tformatter(decode(key, options), value, ret);\n\t}\n\n\tfor (const key of Object.keys(ret)) {\n\t\tconst value = ret[key];\n\t\tif (typeof value === 'object' && value !== null) {\n\t\t\tfor (const k of Object.keys(value)) {\n\t\t\t\tvalue[k] = parseValue(value[k], options);\n\t\t\t}\n\t\t} else {\n\t\t\tret[key] = parseValue(value, options);\n\t\t}\n\t}\n\n\tif (options.sort === false) {\n\t\treturn ret;\n\t}\n\n\treturn (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {\n\t\tconst value = ret[key];\n\t\tif (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {\n\t\t\t// Sort object keys, not values\n\t\t\tresult[key] = keysSorter(value);\n\t\t} else {\n\t\t\tresult[key] = value;\n\t\t}\n\n\t\treturn result;\n\t}, Object.create(null));\n}\n\nexports.extract = extract;\nexports.parse = parse;\n\nexports.stringify = (object, options) => {\n\tif (!object) {\n\t\treturn '';\n\t}\n\n\toptions = Object.assign({\n\t\tencode: true,\n\t\tstrict: true,\n\t\tarrayFormat: 'none',\n\t\tarrayFormatSeparator: ','\n\t}, options);\n\n\tvalidateArrayFormatSeparator(options.arrayFormatSeparator);\n\n\tconst shouldFilter = key => (\n\t\t(options.skipNull && isNullOrUndefined(object[key])) ||\n\t\t(options.skipEmptyString && object[key] === '')\n\t);\n\n\tconst formatter = encoderForArrayFormat(options);\n\n\tconst objectCopy = {};\n\n\tfor (const key of Object.keys(object)) {\n\t\tif (!shouldFilter(key)) {\n\t\t\tobjectCopy[key] = object[key];\n\t\t}\n\t}\n\n\tconst keys = Object.keys(objectCopy);\n\n\tif (options.sort !== false) {\n\t\tkeys.sort(options.sort);\n\t}\n\n\treturn keys.map(key => {\n\t\tconst value = object[key];\n\n\t\tif (value === undefined) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (value === null) {\n\t\t\treturn encode(key, options);\n\t\t}\n\n\t\tif (Array.isArray(value)) {\n\t\t\treturn value\n\t\t\t\t.reduce(formatter(key), [])\n\t\t\t\t.join('&');\n\t\t}\n\n\t\treturn encode(key, options) + '=' + encode(value, options);\n\t}).filter(x => x.length > 0).join('&');\n};\n\nexports.parseUrl = (input, options) => {\n\toptions = Object.assign({\n\t\tdecode: true\n\t}, options);\n\n\tconst [url, hash] = splitOnFirst(input, '#');\n\n\treturn Object.assign(\n\t\t{\n\t\t\turl: url.split('?')[0] || '',\n\t\t\tquery: parse(extract(input), options)\n\t\t},\n\t\toptions && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}\n\t);\n};\n\nexports.stringifyUrl = (input, options) => {\n\toptions = Object.assign({\n\t\tencode: true,\n\t\tstrict: true\n\t}, options);\n\n\tconst url = removeHash(input.url).split('?')[0] || '';\n\tconst queryFromUrl = exports.extract(input.url);\n\tconst parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});\n\n\tconst query = Object.assign(parsedQueryFromUrl, input.query);\n\tlet queryString = exports.stringify(query, options);\n\tif (queryString) {\n\t\tqueryString = `?${queryString}`;\n\t}\n\n\tlet hash = getHash(input.url);\n\tif (input.fragmentIdentifier) {\n\t\thash = `#${encode(input.fragmentIdentifier, options)}`;\n\t}\n\n\treturn `${url}${queryString}${hash}`;\n};\n","'use strict';\nvar token = '%[a-f0-9]{2}';\nvar singleMatcher = new RegExp(token, 'gi');\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn decodeURIComponent(components.join(''));\n\t} catch (err) {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tvar left = components.slice(0, split);\n\tvar right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch (err) {\n\t\tvar tokens = input.match(singleMatcher);\n\n\t\tfor (var i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher);\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tvar replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD'\n\t};\n\n\tvar match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch (err) {\n\t\t\tvar result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tvar entries = Object.keys(replaceMap);\n\n\tfor (var i = 0; i < entries.length; i++) {\n\t\t// Replace all decoded components\n\t\tvar key = entries[i];\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nmodule.exports = function (encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\tencodedURI = encodedURI.replace(/\\+/g, ' ');\n\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch (err) {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n};\n","'use strict';\n\nmodule.exports = (string, separator) => {\n\tif (!(typeof string === 'string' && typeof separator === 'string')) {\n\t\tthrow new TypeError('Expected the arguments to be of type `string`');\n\t}\n\n\tif (separator === '') {\n\t\treturn [string];\n\t}\n\n\tconst separatorIndex = string.indexOf(separator);\n\n\tif (separatorIndex === -1) {\n\t\treturn [string];\n\t}\n\n\treturn [\n\t\tstring.slice(0, separatorIndex),\n\t\tstring.slice(separatorIndex + separator.length)\n\t];\n};\n","/*!\n * mezr v0.6.2\n * https://github.com/niklasramo/mezr\n * Copyright (c) 2016 Niklas Rämö <inramo@gmail.com>\n * Released under the MIT license\n */\n\n(function (global, factory) {\n\n  if (typeof define === 'function' && define.amd) {\n    define([], function () {\n      return factory(global);\n    });\n  }\n  else if (typeof module === 'object' && module.exports) {\n    module.exports = factory(global);\n  }\n  else {\n    global.mezr = factory(global);\n  }\n\n}(this, function (global, undefined) {\n\n  'use strict';\n\n  // Make sure we received a valid window object from the arguments.\n  var win = global.document && global.self === global.document.defaultView ? global : window;\n\n  // Cache document, root and body elements.\n  var doc = win.document;\n  var root = doc.documentElement;\n  var body = doc.body;\n\n  // Throw error if body is not available\n  if (!body) {\n    throw Error('Mezr needs access to body element.');\n  }\n\n  // Cache some often used native functions.\n  var abs = Math.abs;\n  var max = Math.max;\n  var min = Math.min;\n\n  // String to number mappings for element edges.\n  var edges = {\n    content: 1,\n    padding: 2,\n    scroll: 3,\n    border: 4,\n    margin: 5\n  };\n\n  // CSS display values which make it impossible for an element to have a\n  // scrollbar.\n  var unscrollableDisplayValues = ['inline', 'table-column', 'table-column-group'];\n\n  // Temporary bounding client rect data.\n  var tempBCR;\n\n  // Mezr settings.\n  var settings = {};\n\n  // Default options for place method.\n  settings.placeDefaultOptions = {\n    element: null,\n    target: null,\n    position: 'left top left top',\n    offsetX: 0,\n    offsetY: 0,\n    contain: null,\n    adjust: null\n  };\n\n  // Get the primary supported transform property.\n  settings.transform = getSupportedTransform();\n\n  // Check if transformed elements leak fixed elements? According W3C\n  // specification (about transform rendering) a transformed element should\n  // contain fixed elements, but not every browser follows the spec. So we need\n  // to test it.\n  settings.transformLeaksFixed = doesTransformLeakFixed();\n\n  /**\n   * Public methods\n   * **************\n   */\n\n  /**\n   * Returns the width of an element in pixels. Accepts also the window object\n   * (for getting the viewport width) and the document object (for getting the\n   * document width) in place of element.\n   *\n   * @example\n   * mezr.width(elemA, 'content');\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} [edge='border']\n   * @returns {Number}\n   *   - The return value may be fractional when calculating the width of an\n   *     element. For window and document objects the value is always an integer\n   *     though.\n   */\n  function getWidth(el, edge) {\n\n    edge = edge && edges[edge] || 4;\n\n    return getDimension('width', el, edge > 1, edge > 2, edge > 3, edge > 4);\n\n  }\n\n  /**\n   * Returns the height of an element in pixels. Accepts also the window object\n   * (for getting the viewport height) and the document object (for getting the\n   * document height) in place of element.\n   *\n   * @example\n   * mezr.height(elemA, 'content');\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} [edge='border']\n   * @returns {Number}\n   *   - The return value may be fractional when calculating the width of an\n   *     element. For window and document objects the value is always an integer\n   *     though.\n   */\n  function getHeight(el, edge) {\n\n    edge = edge && edges[edge] || 4;\n\n    return getDimension('height', el, edge > 1, edge > 2, edge > 3, edge > 4);\n\n  }\n\n  /**\n   * Returns the element's offset from another element, window or document. In\n   * practice the offset means the vertical and horizontal distance from the\n   * comparison element's northwest corner to the target element's northwest\n   * corner. By default the comparison element is considered to be the document.\n   *\n   * @example\n   * // Returns offset from document's northwest corner to elemA's content\n   * // layer's northwest corner.\n   * mezr.offset(elemA, 'content');\n   *\n   * @example\n   * // Returns offset from window's northwest corner to elemA's content layer's\n   * // northwest corner.\n   * mezr.offset([elemA, 'content'], window);\n   *\n   * @example\n   * // Returns offset from elemB's margin layer's northwest corner to elemA's\n   * // content layer's northwest corner.\n   * mezr.offset([elemA, 'padding'], [elemB, 'margin']);\n   *\n   * @public\n   * @param {(Array|Document|Element|Rectangle|Window)} el\n   * @param {(Array|Document|Edge|Element|Rectangle|Window)} [edge='border']\n   *   - If this argument is a string it is considered to be an edge layer\n   *     definition for the first argument. Otherwise this is considered to be a\n   *     defintion of an element, document or window.\n   * @returns {Offset}\n   */\n  function getOffset(el, edge) {\n\n    // Use default syntax if the element is not an array and the edge is\n    // undefined or a string.\n    if (!Array.isArray(el) && (!edge || typeof edge === 'string')) {\n      return getOffsetFromDocument(el, edge);\n    }\n\n    // Otherwise assume that two element/document/window defintions were\n    // provided and calculate the offset from the second to the first element.\n    else {\n\n      var elemA = [].concat(el);\n      var elemB = [].concat(edge);\n      var offsetA = isPlainObject(el) ? el : getOffsetFromDocument(elemA[0], elemA[1]);\n      var offsetB = isPlainObject(edge) ? edge : getOffsetFromDocument(elemB[0], elemB[1]);\n\n      return {\n        left: offsetA.left - offsetB.left,\n        top: offsetA.top - offsetB.top\n      };\n\n    }\n\n  }\n\n  /**\n   * Returns an object containing the provided element's dimensions and offsets.\n   * This is basically a helper method for calculating an element's dimensions\n   * and offsets simultaneously. Mimics the native getBoundingClientRect method\n   * with the added bonus of allowing to provide the \"edge\" of the element.\n   *\n   * @example\n   * // Returns rect data for elemA (using the element's \"content\" layer in the\n   * // calculations) with the offset calculated from the document.\n   * mezr.offset(elemA, 'content');\n   *\n   * @example\n   * // Returns rect data for elemA (using the element's \"content\" layer in the\n   * // calculations) with the offset calculated from the window.\n   * mezr.rect([elemA, 'content'], window);\n   *\n   * @example\n   * // Returns rect data for elemA (using the element's \"padding\" layer in the\n   * // calculations) with the offset calculated from the elemB (\"margin\"\n   * // layer).\n   * mezr.rect([elemA, 'padding'], [elemB, 'margin']);\n   *\n   * @public\n   * @param {(Array|Document|Element|Rectangle|Window)} el\n   * @param {(Array|Document|Edge|Element|Rectangle|Window)} [edge='border']\n   *   - If this argument is a string it is considered to be an edge layer\n   *     definition for the first argument. Otherwise this is considered to be a\n   *     defintion of an element, document or window.\n   * @returns {Rectangle}\n   */\n  function getRect(el, edge) {\n\n    // Use default syntax if the element is not an array and the edge is\n    // undefined or a string.\n    if (!Array.isArray(el) && (!edge || typeof edge === 'string')) {\n      return getRectInternal(el, edge);\n    }\n\n    // Otherwise assume that two element/document/window defintions were\n    // provided and calculate the offset from the second to the first element.\n    else {\n\n      var elemA = [].concat(el);\n      var elemB = [].concat(edge);\n      var rect = isPlainObject(el) ? el : getRectInternal(elemA[0], elemA[1]);\n      var offsetFrom = isPlainObject(edge) ? edge : getOffsetFromDocument(elemB[0], elemB[1]);\n\n      rect.left = rect.left - offsetFrom.left;\n      rect.top = rect.top - offsetFrom.top;\n\n      return rect;\n\n    }\n\n  }\n\n  /**\n   * Returns the element's containing block, which is considered to be the\n   * closest ancestor element (or window, or document, or the target element\n   * itself) that the target element's positioning is relative to. In other\n   * words, containing block is the element the target element's CSS properties\n   * \"left\", \"right\", \"top\" and \"bottom\" are relative to. You should not confuse\n   * this with the native elem.offsetParent read-only property, which works in a\n   * similar fashion (and even identically in certain situations), but is really\n   * not the same thing (although the name might imply it).\n   *\n   * The logic:\n   * - Document is considered to be the root containing block of all elements\n   *   and the window. Getting the document's containing block will return null.\n   * - Static element does not have a containing block since setting values to\n   *   the \"left\", \"right\", \"top\" and \"bottom\" CSS properties does not have any\n   *   effect on the element's position. Thus, getting the containing block of a\n   *   static element will return null.\n   * - Relative element's containing block is always the element itself.\n   * - Fixed element's containing block is always the closest transformed\n   *   ancestor or window if the element does not have any transformed\n   *   ancestors. An exception is made for browsers which allow fixed elements\n   *   to bypass the W3C specification of transform rendering. In those browsers\n   *   fixed element's containing block is always the window.\n   * - Absolute element's containing block is the closest ancestor element that\n   *   is transformed or positioned (any element which is not static), or\n   *   document if no positioned or transformed ancestor is not found.\n   * - Sticky element is a special case since \"left\", \"right\", \"top\" and\n   *   \"bottom\" CSS properties do not always affect the element's position.\n   *   However, for consistency, the closest scrolling ancestor element is\n   *   always considered as sticky element's containing block, and if no\n   *   scrolling ancestor is found window is returned.\n   * - Root element and body element are considered as equals with all other\n   *   elements and are treated equally with all other elements.\n   *\n   * @example\n   * mezr.containingBlock(elemA);\n   *\n   * @example\n   * mezr.containingBlock(elemA, 'fixed');\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {String} [fakePosition]\n   *   - An optional argument which allows you to get the element's containing\n   *     block as if the element had this CSS position value applied. Using this\n   *     argument does not modify the element's true CSS position in any way,\n   *     it's only used for the calculations.\n   * @returns {?(Document|Element|Window)}\n   */\n  function getContainingBlock(el, fakePosition) {\n\n    var ret;\n    var scrollProps;\n    var parent;\n    var style;\n    var i;\n\n    // If we have document return null right away.\n    if (el === doc) {\n      return null;\n    }\n\n    // If we have window return document right away.\n    if (el === win) {\n      return doc;\n    }\n\n    // Now that we know we have an element in our hands, let's get it's\n    // position. Get element's current position value if a specific position is\n    // not provided.\n    var position = fakePosition || getStyle(el, 'position');\n\n    // Relative element's container is always the element itself.\n    if (position === 'relative') {\n      return el;\n    }\n\n    // If the element is fixed or absolute positioned.\n    else if (position === 'fixed' || position === 'absolute') {\n\n      // If the element is fixed and transforms leak fixed elements, always\n      // return window.\n      if (position === 'fixed' && settings.transformLeaksFixed) {\n        return win;\n      }\n\n      // Alrighty, so now fetch the element's parent (which is document for the\n      // root) and set it as the initial containing block. Fallback to null if\n      // everything else fails.\n      ret = el === root ? doc : el.parentElement || null;\n\n      // If element is fixed positioned: as long as the containing block is an\n      // element and is not transformed, try to get the element's parent element\n      // and fallback to document.\n      if (position === 'fixed') {\n        while (ret && ret !== doc && !isTransformed(ret)) {\n          ret = ret.parentElement || doc;\n        }\n        return ret === doc ? win : ret;\n      }\n\n      // If the element is absolute positioned: as long as the containing block\n      // is an element, is static and is not transformed, try to get the\n      // element's parent element and fallback to document.\n      else {\n        while (ret && ret !== doc && getStyle(ret, 'position') === 'static' && !isTransformed(ret)) {\n          ret = ret.parentElement || doc;\n        }\n        return ret;\n      }\n\n    }\n\n    // Sticky element's container is always the closest scrolling ancestor or\n    // window.\n    else if (position === 'sticky' || position === '-webkit-sticky') {\n\n      scrollProps = ['overflow', 'overflow-y', 'overflow-x'];\n      parent = el.parentNode;\n      el = null;\n\n      while (!el && parent && parent !== doc) {\n\n        for (i = 0; i < 3; i++) {\n          style = getStyle(parent, scrollProps[i]);\n          if (style === 'auto' || style === 'scroll') {\n            el = parent;\n            break;\n          }\n        }\n\n        if (!el) {\n          parent = parent.parentNode;\n        }\n\n      }\n\n      return el || win;\n\n    }\n\n    // If the element is static or an invalid position is provided always return\n    // null.\n    return null;\n\n  }\n\n  /**\n   * Calculate the distance between two elements or rectangles. Returns a\n   * number. If the elements/rectangles overlap the function returns -1. In\n   * other cases the function returns the distance in pixels (fractional)\n   * between the the two elements/rectangles.\n   *\n   * @example\n   * mezr.distance(elemA, elemB);\n   *\n   * @example\n   * mezr.distance([elemA, 'padding'], [elemB, 'margin']);\n\n   * @example\n   * mezr.distance(elemA, {left: 34, top: 56, width: 100, height: 200});\n   *\n   * @public\n   * @param {(Array|Document|Element|Window|Rectangle)} a\n   * @param {(Array|Document|Element|Window|Rectangle)} b\n   * @returns {Number}\n   */\n  function getDistance(a, b) {\n\n    var aRect = getSanitizedRect(a);\n    var bRect = getSanitizedRect(b);\n\n    return getIntersection(aRect, bRect) ? -1 : getDistanceBetweenRects(aRect, bRect);\n\n  }\n\n  /**\n   * Detect if all of the provided elements overlap and calculate the possible\n   * intersection area's dimensions and offsets. If the intersection area exists\n   * the function returns an object containing the intersection area's\n   * dimensions and offsets. Otherwise null is returned.\n   *\n   * @example\n   * mezr.intersection(elemA, elemB);\n   *\n   * @example\n   * mezr.intersection(elemA, [elemB, 'padding'], {\n   *   left: 0,\n   *   top: 10,\n   *   width: 100,\n   *   height: 200\n   * });\n   *\n   * @public\n   * @param {...(Array|Document|Element|Window|Rectangle)} el\n   * @returns {?Rectangle}\n   */\n  function getIntersectionMultiple() {\n\n    // Get the initial intersection of the first two items.\n    var intersection = getIntersection(arguments[0], arguments[1]);\n\n    // If there are more than two items.\n    if (arguments.length > 2) {\n\n      // Loop the arguments until the end or until the intersection is\n      // non-existent.\n      for (var i = 2; i < arguments.length; ++i) {\n        intersection = getIntersection(intersection, arguments[i]);\n        if (!intersection) {\n          break;\n        }\n      }\n\n    }\n\n    return intersection;\n\n  }\n\n  /**\n   * Calculate how much an element overflows another element per each side.\n   *\n   * @example\n   * mezr.overflow(elemA, elemB);\n   *\n   * @example\n   * mezr.overflow(elemA, [elemB, 'padding']);\n   *\n   * @public\n   * @param {(Array|Document|Element|Window|Rectangle)} elA\n   * @param {(Array|Document|Element|Window|Rectangle)} elB\n   * @returns {Overflow}\n   */\n  function getOverflow(elA, elB) {\n\n    var ret = getOverlap(elB, elA);\n\n    return {\n      left: -ret.left,\n      right: -ret.right,\n      top: -ret.top,\n      bottom: -ret.bottom\n    };\n\n  }\n\n  /**\n   * Calculate an element's position (left/top CSS properties) when positioned\n   * relative to another element, window or the document.\n   *\n   * @example\n   * var newElementPosition = mezr.place({\n   *   element: [elemA, 'content'],\n   *   target: [elemB, 'margin'],\n   *   position: 'left top center center',\n   *   offsetX: -5,\n   *   offsetY: '50%',\n   *   contain: {\n   *     within: [elemC, 'padding'],\n   *     onOverflow: {\n   *       left: 'forcepush',\n   *       right: 'push',\n   *       top: 'none',\n   *       bottom: 'push'\n   *     }\n   *   },\n   *   adjust: function (position, data) {\n   *     position.left -= 1;\n   *     position.top += 1;\n   *   }\n   * });\n   *\n   * @public\n   * @param {PlaceOptions} options\n   * @returns {PlaceData}\n   */\n  function getPlace(options) {\n\n    var ret = {};\n    var opts = mergeObjects([settings.placeDefaultOptions, options || {}]);\n    var position = typeof opts.position === 'string' ? opts.position.split(' ') : opts.position;\n    var eRect = getSanitizedRect(opts.element, true);\n    var tRect = getSanitizedRect(opts.target);\n    var isContainDefined = isPlainObject(opts.contain);\n    var container = isContainDefined && opts.contain.within;\n    var overflowAction = isContainDefined && getOverflowAction(opts.contain.onOverflow);\n    var overflowFixLeft = 0;\n    var overflowFixTop = 0;\n    var offsetX = opts.offsetX;\n    var offsetY = opts.offsetY;\n    var cRect;\n    var overlap;\n    var eCurrentOffset;\n\n    // Sanitize offsets and check for percentage values.\n    offsetX = typeof offsetX === 'string' && offsetX.indexOf('%') > -1 ? toFloat(offsetX) / 100 * eRect.width : toFloat(offsetX);\n    offsetY = typeof offsetY === 'string' && offsetY.indexOf('%') > -1 ? toFloat(offsetY) / 100 * eRect.height : toFloat(offsetY);\n\n    // Calculate element's new position (left/top coordinates).\n    ret.left = getPlacePosition(position[0], position[2], tRect.width, tRect.left, eRect.width, eRect.left, offsetX);\n    ret.top = getPlacePosition(position[1], position[3], tRect.height, tRect.top, eRect.height, eRect.top, offsetY);\n\n    // Update element offset data to match the newly calculated position.\n    eRect.left += ret.left;\n    eRect.top += ret.top;\n\n    // If container element and overflow action are defined, let's handle\n    // container's possible overflow.\n    if (container && overflowAction) {\n\n      // Get container rect and overlap data.\n      cRect = getSanitizedRect(container);\n      overlap = getOverlap(eRect, cRect);\n\n      // Handle horizontal overflow.\n      if (overlap.left < 0 || overlap.right < 0) {\n        overflowFixLeft = getPlaceOverflowPush(overflowAction, overlap);\n        ret.left += overflowFixLeft;\n      }\n\n      // Handle vertical overflow.\n      if (overlap.top < 0 || overlap.bottom < 0) {\n        overflowFixTop = getPlaceOverflowPush(overflowAction, overlap, 1);\n        ret.top += overflowFixTop;\n      }\n\n    }\n\n    if (typeof opts.adjust === 'function') {\n\n      // Update element's left and right rect data to account for the possible\n      // overflow correction.\n      if (overflowFixLeft !== 0) {\n        eRect.left += overflowFixLeft;\n        eRect.right = eRect.left + eRect.width;\n      }\n\n      // Update element's top and bottom rect data to account for the possible\n      // overflow correction.\n      if (overflowFixTop !== 0) {\n        eRect.top += overflowFixTop;\n        eRect.bottom = eRect.left + eRect.width;\n      }\n\n      // Get container rect.\n      cRect = container ? cRect || getSanitizedRect(container) : null;\n\n      // Get the element's current offset so we can calculate how much the\n      // element moved.\n      eCurrentOffset = isPlainObject(opts.element) ? opts.element : getOffsetFromDocument.apply(null, [].concat(opts.element));\n\n      // Calculate overlap data based on the new position.\n      overlap = cRect ? getOverlap(eRect, cRect) : null;\n\n      // Provide the final position hash as the first argument (which can be\n      // modified and it affects the return value of this method) and all the\n      // positioning data as the second argument.\n      opts.adjust(ret, {\n        elementRect: eRect,\n        targetRect: tRect,\n        containerRect: cRect,\n        shift: {\n          left: eRect.left - eCurrentOffset.left,\n          top: eRect.top - eCurrentOffset.top\n        },\n        overflow: !overlap ? null : {\n          left: -overlap.left,\n          right: -overlap.right,\n          top: -overlap.top,\n          bottom: -overlap.bottom\n        },\n        overflowCorrection: {\n          left: overflowFixLeft,\n          top: overflowFixTop\n        }\n      });\n\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Private helper functions\n   * ************************\n   */\n\n  /**\n   * Check if a value is a plain object.\n   *\n   * @private\n   * @param {*} val\n   * @returns {Boolean}\n   */\n  function isPlainObject(val) {\n\n    return typeof val === 'object' && Object.prototype.toString.call(val) === '[object Object]';\n\n  }\n\n  /**\n   * Returns the supported transform property's prefix, property name and style\n   * name or null if transforms are not supported.\n   *\n   * @private\n   * @returns {?Object}\n   */\n  function getSupportedTransform() {\n\n    var transforms = ['transform', 'WebkitTransform', 'MozTransform', 'OTransform', 'msTransform'];\n\n    for (var i = 0; i < transforms.length; i++) {\n      if (root.style[transforms[i]] !== undefined) {\n\n        var prop = transforms[i];\n        var prefix = prop.toLowerCase().split('transform')[0];\n\n        return {\n          prefix: prefix,\n          propName: prop,\n          styleName: prefix ? '-' + prefix + '-transform' : prop\n        };\n\n      }\n    }\n\n    return null;\n\n  }\n\n  /**\n   * Detects if transformed elements leak fixed elements. According W3C\n   * transform rendering spec a transformed element should contain even fixed\n   * elements. Meaning that fixed elements are positioned relative to the\n   * closest transformed ancestor element instead of window. However, not every\n   * browser follows the spec (IE and older Firefox), so we need to test it.\n   * https://www.w3.org/TR/css3-2d-transforms/#transform-rendering\n   *\n   * @private\n   * @returns {Boolean}\n   *   - Returns true if transformed elements leak fixed elements, false\n   *     otherwise.\n   */\n  function doesTransformLeakFixed() {\n\n    if (!settings.transform) {\n      return true;\n    }\n\n    var outer = doc.createElement('div');\n    var inner = doc.createElement('div');\n    var leftNotTransformed;\n    var leftTransformed;\n\n    setStyles(outer, {\n      display: 'block',\n      visibility: 'hidden',\n      position: 'absolute',\n      width: '1px',\n      height: '1px',\n      left: '1px',\n      top: '0',\n      margin: '0'\n    });\n\n    setStyles(inner, {\n      display: 'block',\n      position: 'fixed',\n      width: '1px',\n      height: '1px',\n      left: '0',\n      top: '0',\n      margin: '0'\n    });\n\n    outer.appendChild(inner);\n    body.appendChild(outer);\n    leftNotTransformed = inner.getBoundingClientRect().left;\n    outer.style[settings.transform.propName] = 'translateX(0)';\n    leftTransformed = inner.getBoundingClientRect().left;\n    body.removeChild(outer);\n\n    return leftTransformed === leftNotTransformed;\n\n  }\n\n  /**\n   * Returns true if element is transformed, false if not. In practice the\n   * element's display value must be anything else than \"none\" or \"inline\" as\n   * well as have a valid transform value applied in order to be counted as a\n   * transformed element.\n   *\n   * @private\n   * @param {Element} el\n   * @returns {Boolean}\n   */\n  function isTransformed(el) {\n\n    var transform = getStyle(el, settings.transform.styleName);\n    var display = getStyle(el, 'display');\n\n    return transform !== 'none' && display !== 'inline' && display !== 'none';\n\n  }\n\n  /**\n   * Customized parseFloat function which returns 0 instead of NaN.\n   *\n   * @private\n   * @param {Number|String} val\n   * @returns {Number}\n   */\n  function toFloat(val) {\n\n    return parseFloat(val) || 0;\n\n  }\n\n  /**\n   * Deep merge an array of objects into a new object.\n   *\n   * @private\n   * @param {Array} array\n   * @returns {Object}\n   */\n  function mergeObjects(array) {\n\n    var ret = {};\n    var propName;\n    var propVal;\n\n    for (var i = 0, len = array.length; i < len; i++) {\n      for (propName in array[i]) {\n        if (array[i].hasOwnProperty(propName)) {\n          propVal = array[i][propName];\n          ret[propName] = isPlainObject(propVal) ? mergeObjects([propVal]) :\n                          Array.isArray(propVal) ? propVal.slice() :\n                                                   propVal;\n        }\n      }\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Returns the computed value of an element's style property as a string.\n   *\n   * @private\n   * @param {Element} el\n   * @param {String} style\n   * @returns {String}\n   */\n  function getStyle(el, style) {\n\n    return win.getComputedStyle(el, null).getPropertyValue(style);\n\n  }\n\n  /**\n   * Returns the computed value of an element's style property transformed into\n   * a float value.\n   *\n   * @private\n   * @param {Element} el\n   * @param {String} style\n   * @returns {Number}\n   */\n  function getStyleAsFloat(el, style) {\n\n    return toFloat(getStyle(el, style));\n\n  }\n\n  /**\n   * Set inline styles to an element.\n   *\n   * @private\n   * @param {Element} el\n   * @param {Object} styles\n   */\n  function setStyles(el, styles) {\n\n    Object.keys(styles).forEach(function (styleName) {\n      el.style[styleName] = styles[styleName];\n    });\n\n  }\n\n  /**\n   * Calculates how much element overlaps another element from each side.\n   *\n   * @private\n   * @param {(Array|Document|Element|Window|Rectangle)} elA\n   * @param {(Array|Document|Element|Window|Rectangle)} elB\n   * @returns {Overlap}\n   */\n  function getOverlap(elA, elB) {\n\n    var aRect = getSanitizedRect(elA);\n    var bRect = getSanitizedRect(elB);\n\n    return {\n      left: aRect.left - bRect.left,\n      right: (bRect.left + bRect.width) - (aRect.left + aRect.width),\n      top: aRect.top - bRect.top,\n      bottom: (bRect.top + bRect.height) - (aRect.top + aRect.height)\n    };\n\n  }\n\n  /**\n   * Detect if two elements overlap and calculate the possible intersection\n   * area's dimensions and offsets. If the intersection area exists the function\n   * returns an object containing the intersection area's dimensions and\n   * offsets. Otherwise null is returned.\n   *\n   * @private\n   * @param {(Array|Document|Element|Window|Rectangle)} elA\n   * @param {(Array|Document|Element|Window|Rectangle)} elB\n   * @returns {?RectangleExtended}\n   */\n  function getIntersection(elA, elB) {\n\n    var ret = {};\n    var aRect = getSanitizedRect(elA);\n    var bRect = getSanitizedRect(elB);\n    var overlap = getOverlap(aRect, bRect);\n    var intWidth = max(aRect.width + min(overlap.left, 0) + min(overlap.right, 0), 0);\n    var intHeight = max(aRect.height + min(overlap.top, 0) + min(overlap.bottom, 0), 0);\n    var hasIntersection = intWidth > 0 && intHeight > 0;\n\n    if (hasIntersection) {\n      ret.width = intWidth;\n      ret.height = intHeight;\n      ret.left = aRect.left + abs(min(overlap.left, 0));\n      ret.top = aRect.top + abs(min(overlap.top, 0));\n      ret.right = ret.left + ret.width;\n      ret.bottom = ret.top + ret.height;\n    }\n\n    return hasIntersection ? ret : null;\n\n  }\n\n  /**\n   * Calculates the distance between two points in 2D space.\n   *\n   * @private\n   * @param {Number} aLeft\n   * @param {Number} aTop\n   * @param {Number} bLeft\n   * @param {Number} bTop\n   * @returns {Number}\n   */\n  function getDistanceBetweenPoints(aLeft, aTop, bLeft, bTop) {\n\n    return Math.sqrt(Math.pow(bLeft - aLeft, 2) + Math.pow(bTop - aTop, 2));\n\n  }\n\n  /**\n   * Calculates the distance between two unrotated rectangles in 2D space. This\n   * function assumes that the rectangles do not intersect.\n   *\n   * @private\n   * @param {Rectangle} rectA\n   * @param {Rectangle} rectB\n   * @returns {Number}\n   */\n  function getDistanceBetweenRects(rectA, rectB) {\n\n    var ret = 0;\n    var aLeft = rectA.left;\n    var aRight = aLeft + rectA.width;\n    var aTop = rectA.top;\n    var aBottom = aTop + rectA.height;\n    var bLeft = rectB.left;\n    var bRight = bLeft + rectB.width;\n    var bTop = rectB.top;\n    var bBottom = bTop + rectB.height;\n\n    // Calculate shortest corner distance\n    if ((bLeft > aRight || bRight < aLeft) && (bTop > aBottom || bBottom < aTop)) {\n      if (bLeft > aRight) {\n        ret = bBottom < aTop ? getDistanceBetweenPoints(aRight, aTop, bLeft, bBottom) : getDistanceBetweenPoints(aRight, aBottom, bLeft, bTop);\n      }\n      else {\n        ret = bBottom < aTop ? getDistanceBetweenPoints(aLeft, aTop, bRight, bBottom) : getDistanceBetweenPoints(aLeft, aBottom, bRight, bTop);\n      }\n    }\n\n    // Calculate shortest edge distance\n    else {\n      ret = bBottom < aTop ? aTop - bBottom :\n            bLeft > aRight ? bLeft - aRight :\n            bTop > aBottom ? bTop - aBottom :\n            aLeft - bRight;\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Returns the height/width of an element in pixels. The function also accepts\n   * the window object (for obtaining the viewport dimensions) and the document\n   * object (for obtaining the dimensions of the document) in place of element.\n   * Note that this function considers root element's scrollbars as the\n   * document's and window's scrollbars also. Since the root element's\n   * scrollbars are always stuck on the right/bottom edge of the window (even if\n   * you specify width and/or height to root element) they are generally\n   * referred to as viewport scrollbars in the docs. Also note that only\n   * positive margins are included in the result when includeMargin argument is\n   * true.\n   *\n   * @private\n   * @param {String} dimension\n   *   - Accepts \"width\" or \"height\".\n   * @param {(Document|Element|Window)} el\n   * @param {Boolean} [includePadding=false]\n   * @param {Boolean} [includeScrollbar=false]\n   * @param {Boolean} [includeBorder=false]\n   * @param {Boolean} [includeMargin=false]\n   * @returns {Number}\n   *   - The return value may be fractional when calculating the width of an\n   *     element. For window and document objects the value is always an integer\n   *     though.\n   */\n  function getDimension(dimension, el, includePadding, includeScrollbar, includeBorder, includeMargin) {\n\n    var ret;\n    var isHeight = dimension === 'height';\n    var dimensionCapitalized = isHeight ? 'Height' : 'Width';\n    var innerDimension = 'inner' + dimensionCapitalized;\n    var clientDimension = 'client' + dimensionCapitalized;\n    var scrollDimension = 'scroll' + dimensionCapitalized;\n    var sbSize = 0;\n    var edgeA;\n    var edgeB;\n    var borderA;\n    var borderB;\n    var marginA;\n    var marginB;\n\n    if (el.self === win.self) {\n\n      ret = includeScrollbar ? win[innerDimension] : root[clientDimension];\n\n    }\n    else if (el === doc) {\n\n      if (includeScrollbar) {\n        sbSize = win[innerDimension] - root[clientDimension];\n        ret = max(root[scrollDimension] + sbSize, body[scrollDimension] + sbSize, win[innerDimension]);\n      }\n      else {\n        ret = max(root[scrollDimension], body[scrollDimension], root[clientDimension]);\n      }\n\n    }\n    else {\n\n      edgeA = isHeight ? 'top' : 'left';\n      edgeB = isHeight ? 'bottom' : 'right';\n      ret = (tempBCR || el.getBoundingClientRect())[dimension];\n\n      if (!includeScrollbar) {\n\n        if (el === root) {\n          sbSize = win[innerDimension] - root[clientDimension];\n        }\n        else if (unscrollableDisplayValues.indexOf(getStyle(el, 'display')) < 0) {\n          borderA = getStyleAsFloat(el, 'border-' + edgeA + '-width');\n          borderB = getStyleAsFloat(el, 'border-' + edgeB + '-width');\n          sbSize = Math.round(ret) - (el[clientDimension] + borderA + borderB);\n        }\n\n        ret -= sbSize > 0 ? sbSize : 0;\n\n      }\n\n      if (!includePadding) {\n        ret -= getStyleAsFloat(el, 'padding-' + edgeA);\n        ret -= getStyleAsFloat(el, 'padding-' + edgeB);\n      }\n\n      if (!includeBorder) {\n        ret -= borderA !== undefined ? borderA : getStyleAsFloat(el, 'border-' + edgeA + '-width');\n        ret -= borderB !== undefined ? borderB : getStyleAsFloat(el, 'border-' + edgeB + '-width');\n      }\n\n      if (includeMargin) {\n        marginA = getStyleAsFloat(el, 'margin-' + edgeA);\n        marginB = getStyleAsFloat(el, 'margin-' + edgeB);\n        ret += marginA > 0 ? marginA : 0;\n        ret += marginB > 0 ? marginB : 0;\n      }\n\n    }\n\n    return ret > 0 ? ret : 0;\n\n  }\n\n  /**\n   * Returns the element's (or window's) document offset, which in practice\n   * means the vertical and horizontal distance between the element's northwest\n   * corner and the document's northwest corner.\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} [edge='border']\n   * @returns {Offset}\n   */\n  function getOffsetFromDocument(el, edge) {\n\n    var ret = {\n      left: 0,\n      top: 0\n    };\n\n    // Document's offsets are always 0.\n    if (el === doc) {\n      return ret;\n    }\n\n    // Add viewport's scroll left/top to the respective offsets.\n    ret.left = win.pageXOffset || 0;\n    ret.top = win.pageYOffset || 0;\n\n    // Window's offsets are the viewport's scroll left/top values.\n    if (el.self === win.self) {\n      return ret;\n    }\n\n    // Now we know we are calculating an element's offsets so let's first get\n    // the element's bounding client rect. If it is not cached, then just fetch\n    // it.\n    var gbcr = tempBCR || el.getBoundingClientRect();\n\n    // Add bounding client rect's left/top values to the offsets.\n    ret.left += gbcr.left;\n    ret.top += gbcr.top;\n\n    // Sanitize edge.\n    edge = edge && edges[edge] || 4;\n\n    // Exclude element's positive margin size from the offset if needed.\n    if (edge === 5) {\n      var marginLeft = getStyleAsFloat(el, 'margin-left');\n      var marginTop = getStyleAsFloat(el, 'margin-top');\n      ret.left -= marginLeft > 0 ? marginLeft : 0;\n      ret.top -= marginTop > 0 ? marginTop : 0;\n    }\n\n    // Include element's border size to the offset if needed.\n    if (edge < 4) {\n      ret.left += getStyleAsFloat(el, 'border-left-width');\n      ret.top += getStyleAsFloat(el, 'border-top-width');\n    }\n\n    // Include element's padding size to the offset if needed.\n    if (edge === 1) {\n      ret.left += getStyleAsFloat(el, 'padding-left');\n      ret.top += getStyleAsFloat(el, 'padding-top');\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Returns an object containing the provided element's dimensions and offsets.\n   * This is basically just a wrapper for the getRectInternal function which\n   * does some argument normalization before doing the actal calculations. Used\n   * only internally.\n   *\n   * @private\n   * @param {(Array|Document|Element|Window|Rectangle)} el\n   * @param {Boolean} [useStaticOffset=false]\n   * @returns {?Rectangle}\n   */\n  function getSanitizedRect(el, useStaticOffset) {\n\n    // Can't have an empty value.\n    if (!el) {\n      return null;\n    }\n\n    // Let's assume that plain objects are static rectangle definitions.\n    if (isPlainObject(el)) {\n      return el;\n    }\n\n    // We don't know for sure if the provided element is defined with an edge\n    // layer (array syntax) or not. So let's play it safe an normalize the value\n    // to an array.\n    el = [].concat(el);\n\n    return getRectInternal(el[0], el[1], useStaticOffset);\n\n  }\n\n  /**\n   * Returns an object containing the provided element's dimensions and offsets.\n   * This is basically a helper method for calculating an element's dimensions\n   * and offsets simultaneously. Mimics the native getBoundingClientRect method\n   * with the added bonus of allowing to provide the \"edge\" of the element.\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} [edge='border']\n   * @param {Boolean} [useStaticOffset=false]\n   * @returns {Rectangle}\n   */\n  function getRectInternal(el, edge, useStaticOffset) {\n\n    var isElem = el !== doc && el.self !== win.self;\n    var rect;\n\n    // Sanitize edge.\n    edge = edge || 'border';\n\n    // If static offset is required we have to get it before temporary bounding\n    // client rect is cached, since it might need to get the offset of another\n    // element than the cached one.\n    if (useStaticOffset) {\n      rect = getStaticOffset(el, edge);\n    }\n\n    // Cache element's bounding client rect.\n    if (isElem) {\n      tempBCR = el.getBoundingClientRect();\n    }\n\n    // If static offset is not required we know for sure that the temporary\n    // bounding client rect is the same element we need to get offset for.\n    if (!useStaticOffset) {\n      rect = getOffsetFromDocument(el, edge);\n    }\n\n    // Get element's width and height.\n    rect.width = getWidth(el, edge);\n    rect.height = getHeight(el, edge);\n\n    // Calculate element's bottom and right.\n    rect.bottom = rect.top + rect.height;\n    rect.right = rect.left + rect.width;\n\n    // Nullify temporary bounding client rect cache.\n    if (isElem) {\n      tempBCR = null;\n    }\n\n    return rect;\n\n  }\n\n  /**\n   * Returns an element's static offset which in this case means the element's\n   * offset in a state where the element's left and top CSS properties are set\n   * to 0.\n   *\n   * @private\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} edge\n   * @returns {Offset}\n   */\n  function getStaticOffset(el, edge) {\n\n    // Sanitize edge.\n    edge = edge || 'border';\n\n    // For window and document just return normal offset.\n    if (el === win || el === doc) {\n      return getOffsetFromDocument(el, edge);\n    }\n\n    var position = getStyle(el, 'position');\n    var offset = position === 'absolute' || position === 'fixed' ? getOffsetFromDocument(getContainingBlock(el) || doc, 'padding') : getOffsetFromDocument(el, edge);\n\n    if (position === 'relative') {\n\n      var left = getStyle(el, 'left');\n      var right = getStyle(el, 'right');\n      var top = getStyle(el, 'top');\n      var bottom = getStyle(el, 'bottom');\n\n      if (left !== 'auto' || right !== 'auto') {\n        offset.left -= left === 'auto' ? -toFloat(right) : toFloat(left);\n      }\n\n      if (top !== 'auto' || bottom !== 'auto') {\n        offset.top -= top === 'auto' ? -toFloat(bottom) : toFloat(top);\n      }\n\n    }\n    else if (position === 'absolute' || position === 'fixed') {\n\n      // Get edge number.\n      edge = edges[edge];\n\n      // Get left and top margins.\n      var marginLeft = getStyleAsFloat(el, 'margin-left');\n      var marginTop = getStyleAsFloat(el, 'margin-top');\n\n      // If edge is \"margin\" remove negative left/top margins from offset to\n      // account for their effect on position.\n      if (edge === 5) {\n        offset.left -= abs(min(marginLeft, 0));\n        offset.top -= abs(min(marginTop, 0));\n      }\n\n      // If edge is \"border\" or smaller add positive left/top margins and remove\n      // negative left/top margins from offset to account for their effect on\n      // position.\n      if (edge < 5) {\n        offset.left += marginLeft;\n        offset.top += marginTop;\n      }\n\n      // If edge is \"scroll\" or smaller add left/top borders to offset to\n      // account for their effect on position.\n      if (edge < 4) {\n        offset.left += getStyleAsFloat(el, 'border-left-width');\n        offset.top += getStyleAsFloat(el, 'border-top-width');\n      }\n\n      // If edge is \"content\" add left/top paddings to offset to account for\n      // their effect on position.\n      if (edge === 1) {\n        offset.left += getStyleAsFloat(el, 'padding-left');\n        offset.top += getStyleAsFloat(el, 'padding-top');\n      }\n\n    }\n\n    return offset;\n\n  }\n\n  /**\n   * Returns the horizontal or vertical base position of an element relative to\n   * the target element. In other words, this function returns the left and top\n   * CSS values which should be set as to the target element in order to\n   * position it according to the desired position.\n   *\n   * @private\n   * @param {String} elementPosition\n   *   - Element's position: \"left\", \"right\", \"top\", \"bottom\" or \"center\".\n   * @param {String} targetPosition\n   *   - Target's position: \"left\", \"right\", \"top\", \"bottom\" or \"center\".\n   * @param {Number} targetSize\n   *   - Target's width/height in pixels.\n   * @param {Number} targetOffset\n   *   - Target's left/top offset in pixels.\n   * @param {Number} elementSize\n   *   - Element's width/height in pixels.\n   * @param {Number} elementNwOffset\n   *   - Element's left/top northwest offset in pixels.\n   * @param {Number} extraOffset\n   *   - Additional left/top offset in pixels.\n   * @returns {Number}\n   */\n  function getPlacePosition(elementPosition, targetPosition, targetSize, targetOffset, elementSize, elementNwOffset, extraOffset) {\n\n    var placement = elementPosition.charAt(0) + targetPosition.charAt(0);\n    var northwestPoint = targetOffset + extraOffset - elementNwOffset;\n\n    return placement === 'll' || placement === 'tt' ? northwestPoint :\n           placement === 'lc' || placement === 'tc' ? northwestPoint + (targetSize / 2) :\n           placement === 'lr' || placement === 'tb' ? northwestPoint + targetSize :\n           placement === 'cl' || placement === 'ct' ? northwestPoint - (elementSize / 2) :\n           placement === 'cr' || placement === 'cb' ? northwestPoint + targetSize - (elementSize / 2) :\n           placement === 'rl' || placement === 'bt' ? northwestPoint - elementSize :\n           placement === 'rc' || placement === 'bc' ? northwestPoint - elementSize + (targetSize / 2) :\n           placement === 'rr' || placement === 'bb' ? northwestPoint - elementSize + targetSize :\n                                                      northwestPoint + (targetSize / 2) - (elementSize / 2);\n\n  }\n\n  /**\n   * Calculates the distance in pixels that the element needs to be moved in\n   * order to be aligned correctly if the target element overlaps the container.\n   *\n   * @private\n   * @param {OverflowConfig} overflowConfig\n   * @param {Overlap} targetOverlap\n   * @param {Boolean} isVertical\n   * @returns {Number}\n   */\n  function getPlaceOverflowPush(overflowConfig, targetOverlap, isVertical) {\n\n    var ret = 0;\n    var push = 'push';\n    var forcePush = 'forcepush';\n    var sideA = isVertical ? 'top' : 'left';\n    var sideB = isVertical ? 'bottom' : 'right';\n    var sideAConfig = overflowConfig[sideA];\n    var sideBConfig = overflowConfig[sideB];\n    var sideAOverlap = targetOverlap[sideA];\n    var sideBOverlap = targetOverlap[sideB];\n    var sizeDifference = sideAOverlap + sideBOverlap;\n\n    // If pushing is needed from both sides.\n    if ((sideAConfig === push || sideAConfig === forcePush) && (sideBConfig === push || sideBConfig === forcePush) && (sideAOverlap < 0 || sideBOverlap < 0)) {\n\n      // Do push correction from opposite sides with equal force.\n      if (sideAOverlap < sideBOverlap) {\n        ret -= sizeDifference < 0 ? sideAOverlap + abs(sizeDifference / 2) : sideAOverlap;\n      }\n\n      // Do push correction from opposite sides with equal force.\n      if (sideBOverlap < sideAOverlap) {\n        ret += sizeDifference < 0 ? sideBOverlap + abs(sizeDifference / 2) : sideBOverlap;\n      }\n\n      // Update overlap data.\n      sideAOverlap += ret;\n      sideBOverlap -= ret;\n\n      // Check if left/top side forced push correction is needed.\n      if (sideAConfig === forcePush && sideBConfig !== forcePush && sideAOverlap < 0) {\n        ret -= sideAOverlap;\n      }\n\n      // Check if right/top side forced push correction is needed.\n      if (sideBConfig === forcePush && sideAConfig !== forcePush && sideBOverlap < 0) {\n        ret += sideBOverlap;\n      }\n\n    }\n\n    // Check if pushing is needed from left or top side only.\n    else if ((sideAConfig === forcePush || sideAConfig === push) && sideAOverlap < 0) {\n      ret -= sideAOverlap;\n    }\n\n    // Check if pushing is needed from right or bottom side only.\n    else if ((sideBConfig === forcePush || sideBConfig === push) && sideBOverlap < 0) {\n      ret += sideBOverlap;\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Sanitize contain.onOverflow option of .place() method.\n   *\n   * @private\n   * @param {OverflowConfig} overflowConfig\n   * @returns {?overflowConfigSanitized}\n   */\n  function getOverflowAction(overflowConfig) {\n\n    var actionType = typeof overflowConfig;\n    var left = 'none';\n    var right = 'none';\n    var top = 'none';\n    var bottom = 'none';\n\n    // onOverflow string value is always used for all sides.\n    if (actionType === 'string') {\n      left = right = top = bottom = overflowConfig;\n    }\n\n    // onOverflow object value can have properties that present a side\n    // (left/right/top/bottom) or an axis (x/y). Always try to use the side\n    // value first and then fallback to axis value. If all else fails fallback\n    // to \"none\".\n    else if (actionType === 'object') {\n      left = overflowConfig.left || overflowConfig.x || left;\n      right = overflowConfig.right || overflowConfig.x || right;\n      top = overflowConfig.top || overflowConfig.y || top;\n      bottom = overflowConfig.bottom || overflowConfig.y || bottom;\n    }\n\n    // If one side (or more) has a value other than \"none\" we know that the\n    // contain option might have an effect on the positioning.\n    if (left !== 'none' || right !== 'none' || top !== 'none' || bottom !== 'none') {\n      return {\n        left: left,\n        right: right,\n        top: top,\n        bottom: bottom\n      };\n    }\n\n    return null;\n\n  }\n\n  /**\n   * Custom type definitions\n   * ***********************\n   */\n\n  /**\n   * The browser's window object.\n   *\n   * @typedef {Object} Window\n   */\n\n  /**\n   * The document contained in browser's window object.\n   *\n   * @typedef {Object} Document\n   */\n\n  /**\n   * Any HTML element including root and body elements.\n   *\n   * @typedef {Object} Element\n   */\n\n  /**\n   * The name of an element's box model edge which allows you to decide which\n   * areas of the element you want to include in the calculations. Valid edge\n   * values are \"content\", \"padding\", \"scroll\", \"border\" and \"margin\", in that\n   * specific order. Note that \"scroll\" is not a valid element edge accroding to\n   * W3C spec, but it is used here to define whether or not the scrollbar's size\n   * should be included in the calculations. For window and document objects\n   * this argument behaves a bit differently since they cannot have any\n   * paddings, borders or margins. Only \"content\" (without vertical scrollbar’s\n   * width) and \"scroll\" (with vertical scrollbar’s width) are effective values.\n   * \"padding\" is normalized to \"content\" while \"border\" and \"margin\" are\n   * normalized to \"scroll\".\n   *\n   * @typedef {String} Edge\n   */\n\n  /**\n   * @typedef {Object} Rectangle\n   * @property {Number} left\n   *   - Element's horizontal distance from the left edge of the document.\n   * @property {Number} top\n   *   - Element's vertical distance from the top edge of the document.\n   * @property {Number} height\n   *   - Element's height.\n   * @property {Number} width\n   *   - Element's width.\n   */\n\n  /**\n   * @typedef {Object} RectangleExtended\n   * @property {Number} left\n   *   - Element's horizontal distance from the left edge of the document.\n   * @property {Number} right\n   *   - Element's horizontal distance from the left edge of the document plus\n   *     width.\n   * @property {Number} top\n   *   - Element's vertical distance from the top edge of the document\n   * @property {Number} bottom\n   *   - Element's vertical distance from the top edge of the document plus\n   *     height.\n   * @property {Number} height\n   *   - Element's height.\n   * @property {Number} width\n   *   - Element's width.\n   */\n\n  /**\n   * @typedef {Object} Offset\n   * @property {Number} left\n   *   - Element's horizontal distance from the left edge of the document,\n   *     window or other element.\n   * @property {Number} top\n   *   - Element's vertical distance from the top edge of the document, window,\n   *     or other element.\n   */\n\n  /**\n   * @typedef {Object} Overlap\n   * @property {Number} left\n   * @property {Number} top\n   * @property {Number} right\n   * @property {Number} bottom\n   */\n\n  /**\n   * @typedef {Object} Overflow\n   * @property {Number} left\n   * @property {Number} top\n   * @property {Number} right\n   * @property {Number} bottom\n   */\n\n  /**\n   * @typedef {Object} PlaceOptions\n   * @param {(Array|Document|Element|Window|Rectangle)} element\n   * @property {(Array|Document|Element|Window|Rectangle)} target\n   * @property {PlaceOptionsPosition} [position='left top left top']\n   * @property {Number} [offsetX=0]\n   * @property {Number} [offsetY=0]\n   * @property {?PlaceOptionsContainment} [contain=null]\n   */\n\n  /**\n   * Raw positioning data for position option of .place() method.\n   * String syntax: \"elemX elemY targetX targetY\".\n   * Array syntax: [\"elemX\", \"elemY\", \"targetX\", \"targetY\"].\n   * Possible values for elemX and targetX: \"left\", \"center\", \"right\".\n   * Possible values for elemY and targetY: \"top\", \"center\", \"bottom\".\n   *\n   * @typedef {(Array|String)} PlaceOptionsPosition\n   */\n\n  /**\n   * All properties accepts the following values: \"push\", \"forcepush\" and\n   * \"none\".\n   *\n   * @typedef {Object} PlaceOptionsContainment\n   * @property {?(Array|Document|Element|Window|Rectangle)} within\n   * @property {?(OverflowConfig|String)} onOverflow\n   */\n\n  /**\n   * All properties accepts the following values: \"push\", \"forcepush\" and\n   * \"none\". The properties left, right, top and bottom are used to define the\n   * overflow action that should be called when the positioned element overflows\n   * the container element from the respective side. Alternatively you can also\n   * use the properties x and y to define the overflow action per axis. If you\n   * mix side overflow properties with axis overflow properties remember that\n   * the side configuration overwrites the axis configuration.\n   *\n   * @typedef {Object} OverflowConfig\n   * @property {String} [left='none']\n   * @property {String} [right='none']\n   * @property {String} [top='none']\n   * @property {String} [bottom='none']\n   * @property {String} [x='none']\n   * @property {String} [y='none']\n   */\n\n  /**\n   * A sanitized configuration data object for contain.onOverflow option of\n   * .place() method.\n   *\n   * @typedef {Object} OverflowConfigSanitized\n   * @property {String} left\n   * @property {String} right\n   * @property {String} top\n   * @property {String} bottom\n   */\n\n  /**\n   * @typedef {Object} PlaceData\n   * @property {Number} left\n   *   - Target element's new left position.\n   * @property {Number} top\n   *   - Target element's new top position.\n   */\n\n  // Name and return the public methods.\n  return {\n    width: getWidth,\n    height: getHeight,\n    offset: getOffset,\n    rect: getRect,\n    containingBlock: getContainingBlock,\n    distance: getDistance,\n    intersection: getIntersectionMultiple,\n    overflow: getOverflow,\n    place: getPlace,\n    _settings: settings\n  };\n\n}));\n"],"sourceRoot":""}