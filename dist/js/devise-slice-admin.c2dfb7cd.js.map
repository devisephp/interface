{"version":3,"sources":["webpack:///./node_modules/query-string/node_modules/strict-uri-encode/index.js","webpack:///./node_modules/query-string/index.js","webpack:///./node_modules/filter-obj/index.js","webpack:///./node_modules/decode-uri-component/index.js","webpack:///./node_modules/split-on-first/index.js","webpack:///./node_modules/mezr/mezr.js"],"names":["module","exports","str","encodeURIComponent","replace","x","charCodeAt","toString","toUpperCase","strictUriEncode","decodeComponent","splitOnFirst","filterObject","isNullOrUndefined","value","undefined","encoderForArrayFormat","options","arrayFormat","key","result","index","length","skipNull","skipEmptyString","encode","join","arrayFormatSeparator","parserForArrayFormat","accumulator","exec","concat","isArray","includes","isEncodedArray","decode","newValue","split","map","item","validateArrayFormatSeparator","TypeError","strict","keysSorter","input","Array","sort","Object","keys","a","b","Number","removeHash","hashStart","indexOf","slice","getHash","url","hash","extract","queryStart","parseValue","parseNumbers","isNaN","trim","parseBooleans","toLowerCase","parse","query","assign","formatter","ret","create","param","k","reduce","Boolean","stringify","object","shouldFilter","objectCopy","filter","parseUrl","url_","parseFragmentIdentifier","fragmentIdentifier","stringifyUrl","queryFromUrl","parsedQueryFromUrl","queryString","pick","exclude","exclusionFilter","obj","predicate","isArr","i","val","token","singleMatcher","RegExp","multiMatcher","decodeComponents","components","decodeURIComponent","err","left","right","prototype","call","tokens","match","customDecodeURIComponent","replaceMap","entries","encodedURI","string","separator","separatorIndex","global","factory","this","win","document","self","defaultView","window","doc","root","documentElement","body","Error","tempBCR","abs","Math","max","min","edges","content","padding","scroll","border","margin","unscrollableDisplayValues","settings","getWidth","el","edge","getDimension","getHeight","getOffset","elemA","elemB","offsetA","isPlainObject","getOffsetFromDocument","offsetB","top","getRect","rect","getRectInternal","offsetFrom","getContainingBlock","fakePosition","scrollProps","parent","style","position","getStyle","transformLeaksFixed","parentElement","isTransformed","parentNode","getDistance","aRect","getSanitizedRect","bRect","getIntersection","getDistanceBetweenRects","getIntersectionMultiple","intersection","arguments","getOverflow","elA","elB","getOverlap","bottom","getPlace","cRect","overlap","eCurrentOffset","opts","mergeObjects","placeDefaultOptions","eRect","element","tRect","target","isContainDefined","contain","container","within","overflowAction","getOverflowAction","onOverflow","overflowFixLeft","overflowFixTop","offsetX","offsetY","toFloat","width","height","getPlacePosition","getPlaceOverflowPush","adjust","apply","elementRect","targetRect","containerRect","shift","overflow","overflowCorrection","getSupportedTransform","transforms","prop","prefix","propName","styleName","doesTransformLeakFixed","transform","leftNotTransformed","leftTransformed","outer","createElement","inner","setStyles","display","visibility","appendChild","getBoundingClientRect","removeChild","parseFloat","array","propVal","len","hasOwnProperty","getComputedStyle","getPropertyValue","getStyleAsFloat","styles","forEach","intWidth","intHeight","hasIntersection","getDistanceBetweenPoints","aLeft","aTop","bLeft","bTop","sqrt","pow","rectA","rectB","aRight","aBottom","bRight","bBottom","dimension","includePadding","includeScrollbar","includeBorder","includeMargin","edgeA","edgeB","borderA","borderB","marginA","marginB","isHeight","dimensionCapitalized","innerDimension","clientDimension","scrollDimension","sbSize","round","pageXOffset","pageYOffset","gbcr","marginLeft","marginTop","useStaticOffset","isElem","getStaticOffset","offset","elementPosition","targetPosition","targetSize","targetOffset","elementSize","elementNwOffset","extraOffset","placement","charAt","northwestPoint","overflowConfig","targetOverlap","isVertical","push","forcePush","sideA","sideB","sideAConfig","sideBConfig","sideAOverlap","sideBOverlap","sizeDifference","actionType","y","containingBlock","distance","place","_settings"],"mappings":"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","file":"js/devise-slice-admin.c2dfb7cd.js","sourcesContent":["'use strict';\nmodule.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);\n","'use strict';\nconst strictUriEncode = require('strict-uri-encode');\nconst decodeComponent = require('decode-uri-component');\nconst splitOnFirst = require('split-on-first');\nconst filterObject = require('filter-obj');\n\nconst isNullOrUndefined = value => value === null || value === undefined;\n\nfunction encoderForArrayFormat(options) {\n\tswitch (options.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tconst index = result.length;\n\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), '[', index, ']'].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [\n\t\t\t\t\t...result,\n\t\t\t\t\t[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')\n\t\t\t\t];\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), '[]'].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), '[]=', encode(value, options)].join('')];\n\t\t\t};\n\n\t\tcase 'comma':\n\t\tcase 'separator':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (value === null || value === undefined || value.length === 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (result.length === 0) {\n\t\t\t\t\treturn [[encode(key, options), '=', encode(value, options)].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [[result, encode(value, options)].join(options.arrayFormatSeparator)];\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, encode(key, options)];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), '=', encode(value, options)].join('')];\n\t\t\t};\n\t}\n}\n\nfunction parserForArrayFormat(options) {\n\tlet result;\n\n\tswitch (options.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /\\[(\\d*)\\]$/.exec(key);\n\n\t\t\t\tkey = key.replace(/\\[\\d*\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = {};\n\t\t\t\t}\n\n\t\t\t\taccumulator[key][result[1]] = value;\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /(\\[\\])$/.exec(key);\n\t\t\t\tkey = key.replace(/\\[\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\n\t\tcase 'comma':\n\t\tcase 'separator':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tconst isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);\n\t\t\t\tconst isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));\n\t\t\t\tvalue = isEncodedArray ? decode(value, options) : value;\n\t\t\t\tconst newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);\n\t\t\t\taccumulator[key] = newValue;\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\t}\n}\n\nfunction validateArrayFormatSeparator(value) {\n\tif (typeof value !== 'string' || value.length !== 1) {\n\t\tthrow new TypeError('arrayFormatSeparator must be single character string');\n\t}\n}\n\nfunction encode(value, options) {\n\tif (options.encode) {\n\t\treturn options.strict ? strictUriEncode(value) : encodeURIComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction decode(value, options) {\n\tif (options.decode) {\n\t\treturn decodeComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction keysSorter(input) {\n\tif (Array.isArray(input)) {\n\t\treturn input.sort();\n\t}\n\n\tif (typeof input === 'object') {\n\t\treturn keysSorter(Object.keys(input))\n\t\t\t.sort((a, b) => Number(a) - Number(b))\n\t\t\t.map(key => input[key]);\n\t}\n\n\treturn input;\n}\n\nfunction removeHash(input) {\n\tconst hashStart = input.indexOf('#');\n\tif (hashStart !== -1) {\n\t\tinput = input.slice(0, hashStart);\n\t}\n\n\treturn input;\n}\n\nfunction getHash(url) {\n\tlet hash = '';\n\tconst hashStart = url.indexOf('#');\n\tif (hashStart !== -1) {\n\t\thash = url.slice(hashStart);\n\t}\n\n\treturn hash;\n}\n\nfunction extract(input) {\n\tinput = removeHash(input);\n\tconst queryStart = input.indexOf('?');\n\tif (queryStart === -1) {\n\t\treturn '';\n\t}\n\n\treturn input.slice(queryStart + 1);\n}\n\nfunction parseValue(value, options) {\n\tif (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {\n\t\tvalue = Number(value);\n\t} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {\n\t\tvalue = value.toLowerCase() === 'true';\n\t}\n\n\treturn value;\n}\n\nfunction parse(query, options) {\n\toptions = Object.assign({\n\t\tdecode: true,\n\t\tsort: true,\n\t\tarrayFormat: 'none',\n\t\tarrayFormatSeparator: ',',\n\t\tparseNumbers: false,\n\t\tparseBooleans: false\n\t}, options);\n\n\tvalidateArrayFormatSeparator(options.arrayFormatSeparator);\n\n\tconst formatter = parserForArrayFormat(options);\n\n\t// Create an object with no prototype\n\tconst ret = Object.create(null);\n\n\tif (typeof query !== 'string') {\n\t\treturn ret;\n\t}\n\n\tquery = query.trim().replace(/^[?#&]/, '');\n\n\tif (!query) {\n\t\treturn ret;\n\t}\n\n\tfor (const param of query.split('&')) {\n\t\tif (param === '') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet [key, value] = splitOnFirst(options.decode ? param.replace(/\\+/g, ' ') : param, '=');\n\n\t\t// Missing `=` should be `null`:\n\t\t// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\t\tvalue = value === undefined ? null : ['comma', 'separator'].includes(options.arrayFormat) ? value : decode(value, options);\n\t\tformatter(decode(key, options), value, ret);\n\t}\n\n\tfor (const key of Object.keys(ret)) {\n\t\tconst value = ret[key];\n\t\tif (typeof value === 'object' && value !== null) {\n\t\t\tfor (const k of Object.keys(value)) {\n\t\t\t\tvalue[k] = parseValue(value[k], options);\n\t\t\t}\n\t\t} else {\n\t\t\tret[key] = parseValue(value, options);\n\t\t}\n\t}\n\n\tif (options.sort === false) {\n\t\treturn ret;\n\t}\n\n\treturn (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {\n\t\tconst value = ret[key];\n\t\tif (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {\n\t\t\t// Sort object keys, not values\n\t\t\tresult[key] = keysSorter(value);\n\t\t} else {\n\t\t\tresult[key] = value;\n\t\t}\n\n\t\treturn result;\n\t}, Object.create(null));\n}\n\nexports.extract = extract;\nexports.parse = parse;\n\nexports.stringify = (object, options) => {\n\tif (!object) {\n\t\treturn '';\n\t}\n\n\toptions = Object.assign({\n\t\tencode: true,\n\t\tstrict: true,\n\t\tarrayFormat: 'none',\n\t\tarrayFormatSeparator: ','\n\t}, options);\n\n\tvalidateArrayFormatSeparator(options.arrayFormatSeparator);\n\n\tconst shouldFilter = key => (\n\t\t(options.skipNull && isNullOrUndefined(object[key])) ||\n\t\t(options.skipEmptyString && object[key] === '')\n\t);\n\n\tconst formatter = encoderForArrayFormat(options);\n\n\tconst objectCopy = {};\n\n\tfor (const key of Object.keys(object)) {\n\t\tif (!shouldFilter(key)) {\n\t\t\tobjectCopy[key] = object[key];\n\t\t}\n\t}\n\n\tconst keys = Object.keys(objectCopy);\n\n\tif (options.sort !== false) {\n\t\tkeys.sort(options.sort);\n\t}\n\n\treturn keys.map(key => {\n\t\tconst value = object[key];\n\n\t\tif (value === undefined) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (value === null) {\n\t\t\treturn encode(key, options);\n\t\t}\n\n\t\tif (Array.isArray(value)) {\n\t\t\treturn value\n\t\t\t\t.reduce(formatter(key), [])\n\t\t\t\t.join('&');\n\t\t}\n\n\t\treturn encode(key, options) + '=' + encode(value, options);\n\t}).filter(x => x.length > 0).join('&');\n};\n\nexports.parseUrl = (url, options) => {\n\toptions = Object.assign({\n\t\tdecode: true\n\t}, options);\n\n\tconst [url_, hash] = splitOnFirst(url, '#');\n\n\treturn Object.assign(\n\t\t{\n\t\t\turl: url_.split('?')[0] || '',\n\t\t\tquery: parse(extract(url), options)\n\t\t},\n\t\toptions && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}\n\t);\n};\n\nexports.stringifyUrl = (object, options) => {\n\toptions = Object.assign({\n\t\tencode: true,\n\t\tstrict: true\n\t}, options);\n\n\tconst url = removeHash(object.url).split('?')[0] || '';\n\tconst queryFromUrl = exports.extract(object.url);\n\tconst parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});\n\n\tconst query = Object.assign(parsedQueryFromUrl, object.query);\n\tlet queryString = exports.stringify(query, options);\n\tif (queryString) {\n\t\tqueryString = `?${queryString}`;\n\t}\n\n\tlet hash = getHash(object.url);\n\tif (object.fragmentIdentifier) {\n\t\thash = `#${encode(object.fragmentIdentifier, options)}`;\n\t}\n\n\treturn `${url}${queryString}${hash}`;\n};\n\nexports.pick = (input, filter, options) => {\n\toptions = Object.assign({\n\t\tparseFragmentIdentifier: true\n\t}, options);\n\n\tconst {url, query, fragmentIdentifier} = exports.parseUrl(input, options);\n\treturn exports.stringifyUrl({\n\t\turl,\n\t\tquery: filterObject(query, filter),\n\t\tfragmentIdentifier\n\t}, options);\n};\n\nexports.exclude = (input, filter, options) => {\n\tconst exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);\n\n\treturn exports.pick(input, exclusionFilter, options);\n};\n","'use strict';\nmodule.exports = function (obj, predicate) {\n\tvar ret = {};\n\tvar keys = Object.keys(obj);\n\tvar isArr = Array.isArray(predicate);\n\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar key = keys[i];\n\t\tvar val = obj[key];\n\n\t\tif (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {\n\t\t\tret[key] = val;\n\t\t}\n\t}\n\n\treturn ret;\n};\n","'use strict';\nvar token = '%[a-f0-9]{2}';\nvar singleMatcher = new RegExp(token, 'gi');\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn decodeURIComponent(components.join(''));\n\t} catch (err) {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tvar left = components.slice(0, split);\n\tvar right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch (err) {\n\t\tvar tokens = input.match(singleMatcher);\n\n\t\tfor (var i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher);\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tvar replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD'\n\t};\n\n\tvar match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch (err) {\n\t\t\tvar result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tvar entries = Object.keys(replaceMap);\n\n\tfor (var i = 0; i < entries.length; i++) {\n\t\t// Replace all decoded components\n\t\tvar key = entries[i];\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nmodule.exports = function (encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\tencodedURI = encodedURI.replace(/\\+/g, ' ');\n\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch (err) {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n};\n","'use strict';\n\nmodule.exports = (string, separator) => {\n\tif (!(typeof string === 'string' && typeof separator === 'string')) {\n\t\tthrow new TypeError('Expected the arguments to be of type `string`');\n\t}\n\n\tif (separator === '') {\n\t\treturn [string];\n\t}\n\n\tconst separatorIndex = string.indexOf(separator);\n\n\tif (separatorIndex === -1) {\n\t\treturn [string];\n\t}\n\n\treturn [\n\t\tstring.slice(0, separatorIndex),\n\t\tstring.slice(separatorIndex + separator.length)\n\t];\n};\n","/*!\n * mezr v0.6.2\n * https://github.com/niklasramo/mezr\n * Copyright (c) 2016 Niklas Rämö <inramo@gmail.com>\n * Released under the MIT license\n */\n\n(function (global, factory) {\n\n  if (typeof define === 'function' && define.amd) {\n    define([], function () {\n      return factory(global);\n    });\n  }\n  else if (typeof module === 'object' && module.exports) {\n    module.exports = factory(global);\n  }\n  else {\n    global.mezr = factory(global);\n  }\n\n}(this, function (global, undefined) {\n\n  'use strict';\n\n  // Make sure we received a valid window object from the arguments.\n  var win = global.document && global.self === global.document.defaultView ? global : window;\n\n  // Cache document, root and body elements.\n  var doc = win.document;\n  var root = doc.documentElement;\n  var body = doc.body;\n\n  // Throw error if body is not available\n  if (!body) {\n    throw Error('Mezr needs access to body element.');\n  }\n\n  // Cache some often used native functions.\n  var abs = Math.abs;\n  var max = Math.max;\n  var min = Math.min;\n\n  // String to number mappings for element edges.\n  var edges = {\n    content: 1,\n    padding: 2,\n    scroll: 3,\n    border: 4,\n    margin: 5\n  };\n\n  // CSS display values which make it impossible for an element to have a\n  // scrollbar.\n  var unscrollableDisplayValues = ['inline', 'table-column', 'table-column-group'];\n\n  // Temporary bounding client rect data.\n  var tempBCR;\n\n  // Mezr settings.\n  var settings = {};\n\n  // Default options for place method.\n  settings.placeDefaultOptions = {\n    element: null,\n    target: null,\n    position: 'left top left top',\n    offsetX: 0,\n    offsetY: 0,\n    contain: null,\n    adjust: null\n  };\n\n  // Get the primary supported transform property.\n  settings.transform = getSupportedTransform();\n\n  // Check if transformed elements leak fixed elements? According W3C\n  // specification (about transform rendering) a transformed element should\n  // contain fixed elements, but not every browser follows the spec. So we need\n  // to test it.\n  settings.transformLeaksFixed = doesTransformLeakFixed();\n\n  /**\n   * Public methods\n   * **************\n   */\n\n  /**\n   * Returns the width of an element in pixels. Accepts also the window object\n   * (for getting the viewport width) and the document object (for getting the\n   * document width) in place of element.\n   *\n   * @example\n   * mezr.width(elemA, 'content');\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} [edge='border']\n   * @returns {Number}\n   *   - The return value may be fractional when calculating the width of an\n   *     element. For window and document objects the value is always an integer\n   *     though.\n   */\n  function getWidth(el, edge) {\n\n    edge = edge && edges[edge] || 4;\n\n    return getDimension('width', el, edge > 1, edge > 2, edge > 3, edge > 4);\n\n  }\n\n  /**\n   * Returns the height of an element in pixels. Accepts also the window object\n   * (for getting the viewport height) and the document object (for getting the\n   * document height) in place of element.\n   *\n   * @example\n   * mezr.height(elemA, 'content');\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} [edge='border']\n   * @returns {Number}\n   *   - The return value may be fractional when calculating the width of an\n   *     element. For window and document objects the value is always an integer\n   *     though.\n   */\n  function getHeight(el, edge) {\n\n    edge = edge && edges[edge] || 4;\n\n    return getDimension('height', el, edge > 1, edge > 2, edge > 3, edge > 4);\n\n  }\n\n  /**\n   * Returns the element's offset from another element, window or document. In\n   * practice the offset means the vertical and horizontal distance from the\n   * comparison element's northwest corner to the target element's northwest\n   * corner. By default the comparison element is considered to be the document.\n   *\n   * @example\n   * // Returns offset from document's northwest corner to elemA's content\n   * // layer's northwest corner.\n   * mezr.offset(elemA, 'content');\n   *\n   * @example\n   * // Returns offset from window's northwest corner to elemA's content layer's\n   * // northwest corner.\n   * mezr.offset([elemA, 'content'], window);\n   *\n   * @example\n   * // Returns offset from elemB's margin layer's northwest corner to elemA's\n   * // content layer's northwest corner.\n   * mezr.offset([elemA, 'padding'], [elemB, 'margin']);\n   *\n   * @public\n   * @param {(Array|Document|Element|Rectangle|Window)} el\n   * @param {(Array|Document|Edge|Element|Rectangle|Window)} [edge='border']\n   *   - If this argument is a string it is considered to be an edge layer\n   *     definition for the first argument. Otherwise this is considered to be a\n   *     defintion of an element, document or window.\n   * @returns {Offset}\n   */\n  function getOffset(el, edge) {\n\n    // Use default syntax if the element is not an array and the edge is\n    // undefined or a string.\n    if (!Array.isArray(el) && (!edge || typeof edge === 'string')) {\n      return getOffsetFromDocument(el, edge);\n    }\n\n    // Otherwise assume that two element/document/window defintions were\n    // provided and calculate the offset from the second to the first element.\n    else {\n\n      var elemA = [].concat(el);\n      var elemB = [].concat(edge);\n      var offsetA = isPlainObject(el) ? el : getOffsetFromDocument(elemA[0], elemA[1]);\n      var offsetB = isPlainObject(edge) ? edge : getOffsetFromDocument(elemB[0], elemB[1]);\n\n      return {\n        left: offsetA.left - offsetB.left,\n        top: offsetA.top - offsetB.top\n      };\n\n    }\n\n  }\n\n  /**\n   * Returns an object containing the provided element's dimensions and offsets.\n   * This is basically a helper method for calculating an element's dimensions\n   * and offsets simultaneously. Mimics the native getBoundingClientRect method\n   * with the added bonus of allowing to provide the \"edge\" of the element.\n   *\n   * @example\n   * // Returns rect data for elemA (using the element's \"content\" layer in the\n   * // calculations) with the offset calculated from the document.\n   * mezr.offset(elemA, 'content');\n   *\n   * @example\n   * // Returns rect data for elemA (using the element's \"content\" layer in the\n   * // calculations) with the offset calculated from the window.\n   * mezr.rect([elemA, 'content'], window);\n   *\n   * @example\n   * // Returns rect data for elemA (using the element's \"padding\" layer in the\n   * // calculations) with the offset calculated from the elemB (\"margin\"\n   * // layer).\n   * mezr.rect([elemA, 'padding'], [elemB, 'margin']);\n   *\n   * @public\n   * @param {(Array|Document|Element|Rectangle|Window)} el\n   * @param {(Array|Document|Edge|Element|Rectangle|Window)} [edge='border']\n   *   - If this argument is a string it is considered to be an edge layer\n   *     definition for the first argument. Otherwise this is considered to be a\n   *     defintion of an element, document or window.\n   * @returns {Rectangle}\n   */\n  function getRect(el, edge) {\n\n    // Use default syntax if the element is not an array and the edge is\n    // undefined or a string.\n    if (!Array.isArray(el) && (!edge || typeof edge === 'string')) {\n      return getRectInternal(el, edge);\n    }\n\n    // Otherwise assume that two element/document/window defintions were\n    // provided and calculate the offset from the second to the first element.\n    else {\n\n      var elemA = [].concat(el);\n      var elemB = [].concat(edge);\n      var rect = isPlainObject(el) ? el : getRectInternal(elemA[0], elemA[1]);\n      var offsetFrom = isPlainObject(edge) ? edge : getOffsetFromDocument(elemB[0], elemB[1]);\n\n      rect.left = rect.left - offsetFrom.left;\n      rect.top = rect.top - offsetFrom.top;\n\n      return rect;\n\n    }\n\n  }\n\n  /**\n   * Returns the element's containing block, which is considered to be the\n   * closest ancestor element (or window, or document, or the target element\n   * itself) that the target element's positioning is relative to. In other\n   * words, containing block is the element the target element's CSS properties\n   * \"left\", \"right\", \"top\" and \"bottom\" are relative to. You should not confuse\n   * this with the native elem.offsetParent read-only property, which works in a\n   * similar fashion (and even identically in certain situations), but is really\n   * not the same thing (although the name might imply it).\n   *\n   * The logic:\n   * - Document is considered to be the root containing block of all elements\n   *   and the window. Getting the document's containing block will return null.\n   * - Static element does not have a containing block since setting values to\n   *   the \"left\", \"right\", \"top\" and \"bottom\" CSS properties does not have any\n   *   effect on the element's position. Thus, getting the containing block of a\n   *   static element will return null.\n   * - Relative element's containing block is always the element itself.\n   * - Fixed element's containing block is always the closest transformed\n   *   ancestor or window if the element does not have any transformed\n   *   ancestors. An exception is made for browsers which allow fixed elements\n   *   to bypass the W3C specification of transform rendering. In those browsers\n   *   fixed element's containing block is always the window.\n   * - Absolute element's containing block is the closest ancestor element that\n   *   is transformed or positioned (any element which is not static), or\n   *   document if no positioned or transformed ancestor is not found.\n   * - Sticky element is a special case since \"left\", \"right\", \"top\" and\n   *   \"bottom\" CSS properties do not always affect the element's position.\n   *   However, for consistency, the closest scrolling ancestor element is\n   *   always considered as sticky element's containing block, and if no\n   *   scrolling ancestor is found window is returned.\n   * - Root element and body element are considered as equals with all other\n   *   elements and are treated equally with all other elements.\n   *\n   * @example\n   * mezr.containingBlock(elemA);\n   *\n   * @example\n   * mezr.containingBlock(elemA, 'fixed');\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {String} [fakePosition]\n   *   - An optional argument which allows you to get the element's containing\n   *     block as if the element had this CSS position value applied. Using this\n   *     argument does not modify the element's true CSS position in any way,\n   *     it's only used for the calculations.\n   * @returns {?(Document|Element|Window)}\n   */\n  function getContainingBlock(el, fakePosition) {\n\n    var ret;\n    var scrollProps;\n    var parent;\n    var style;\n    var i;\n\n    // If we have document return null right away.\n    if (el === doc) {\n      return null;\n    }\n\n    // If we have window return document right away.\n    if (el === win) {\n      return doc;\n    }\n\n    // Now that we know we have an element in our hands, let's get it's\n    // position. Get element's current position value if a specific position is\n    // not provided.\n    var position = fakePosition || getStyle(el, 'position');\n\n    // Relative element's container is always the element itself.\n    if (position === 'relative') {\n      return el;\n    }\n\n    // If the element is fixed or absolute positioned.\n    else if (position === 'fixed' || position === 'absolute') {\n\n      // If the element is fixed and transforms leak fixed elements, always\n      // return window.\n      if (position === 'fixed' && settings.transformLeaksFixed) {\n        return win;\n      }\n\n      // Alrighty, so now fetch the element's parent (which is document for the\n      // root) and set it as the initial containing block. Fallback to null if\n      // everything else fails.\n      ret = el === root ? doc : el.parentElement || null;\n\n      // If element is fixed positioned: as long as the containing block is an\n      // element and is not transformed, try to get the element's parent element\n      // and fallback to document.\n      if (position === 'fixed') {\n        while (ret && ret !== doc && !isTransformed(ret)) {\n          ret = ret.parentElement || doc;\n        }\n        return ret === doc ? win : ret;\n      }\n\n      // If the element is absolute positioned: as long as the containing block\n      // is an element, is static and is not transformed, try to get the\n      // element's parent element and fallback to document.\n      else {\n        while (ret && ret !== doc && getStyle(ret, 'position') === 'static' && !isTransformed(ret)) {\n          ret = ret.parentElement || doc;\n        }\n        return ret;\n      }\n\n    }\n\n    // Sticky element's container is always the closest scrolling ancestor or\n    // window.\n    else if (position === 'sticky' || position === '-webkit-sticky') {\n\n      scrollProps = ['overflow', 'overflow-y', 'overflow-x'];\n      parent = el.parentNode;\n      el = null;\n\n      while (!el && parent && parent !== doc) {\n\n        for (i = 0; i < 3; i++) {\n          style = getStyle(parent, scrollProps[i]);\n          if (style === 'auto' || style === 'scroll') {\n            el = parent;\n            break;\n          }\n        }\n\n        if (!el) {\n          parent = parent.parentNode;\n        }\n\n      }\n\n      return el || win;\n\n    }\n\n    // If the element is static or an invalid position is provided always return\n    // null.\n    return null;\n\n  }\n\n  /**\n   * Calculate the distance between two elements or rectangles. Returns a\n   * number. If the elements/rectangles overlap the function returns -1. In\n   * other cases the function returns the distance in pixels (fractional)\n   * between the the two elements/rectangles.\n   *\n   * @example\n   * mezr.distance(elemA, elemB);\n   *\n   * @example\n   * mezr.distance([elemA, 'padding'], [elemB, 'margin']);\n\n   * @example\n   * mezr.distance(elemA, {left: 34, top: 56, width: 100, height: 200});\n   *\n   * @public\n   * @param {(Array|Document|Element|Window|Rectangle)} a\n   * @param {(Array|Document|Element|Window|Rectangle)} b\n   * @returns {Number}\n   */\n  function getDistance(a, b) {\n\n    var aRect = getSanitizedRect(a);\n    var bRect = getSanitizedRect(b);\n\n    return getIntersection(aRect, bRect) ? -1 : getDistanceBetweenRects(aRect, bRect);\n\n  }\n\n  /**\n   * Detect if all of the provided elements overlap and calculate the possible\n   * intersection area's dimensions and offsets. If the intersection area exists\n   * the function returns an object containing the intersection area's\n   * dimensions and offsets. Otherwise null is returned.\n   *\n   * @example\n   * mezr.intersection(elemA, elemB);\n   *\n   * @example\n   * mezr.intersection(elemA, [elemB, 'padding'], {\n   *   left: 0,\n   *   top: 10,\n   *   width: 100,\n   *   height: 200\n   * });\n   *\n   * @public\n   * @param {...(Array|Document|Element|Window|Rectangle)} el\n   * @returns {?Rectangle}\n   */\n  function getIntersectionMultiple() {\n\n    // Get the initial intersection of the first two items.\n    var intersection = getIntersection(arguments[0], arguments[1]);\n\n    // If there are more than two items.\n    if (arguments.length > 2) {\n\n      // Loop the arguments until the end or until the intersection is\n      // non-existent.\n      for (var i = 2; i < arguments.length; ++i) {\n        intersection = getIntersection(intersection, arguments[i]);\n        if (!intersection) {\n          break;\n        }\n      }\n\n    }\n\n    return intersection;\n\n  }\n\n  /**\n   * Calculate how much an element overflows another element per each side.\n   *\n   * @example\n   * mezr.overflow(elemA, elemB);\n   *\n   * @example\n   * mezr.overflow(elemA, [elemB, 'padding']);\n   *\n   * @public\n   * @param {(Array|Document|Element|Window|Rectangle)} elA\n   * @param {(Array|Document|Element|Window|Rectangle)} elB\n   * @returns {Overflow}\n   */\n  function getOverflow(elA, elB) {\n\n    var ret = getOverlap(elB, elA);\n\n    return {\n      left: -ret.left,\n      right: -ret.right,\n      top: -ret.top,\n      bottom: -ret.bottom\n    };\n\n  }\n\n  /**\n   * Calculate an element's position (left/top CSS properties) when positioned\n   * relative to another element, window or the document.\n   *\n   * @example\n   * var newElementPosition = mezr.place({\n   *   element: [elemA, 'content'],\n   *   target: [elemB, 'margin'],\n   *   position: 'left top center center',\n   *   offsetX: -5,\n   *   offsetY: '50%',\n   *   contain: {\n   *     within: [elemC, 'padding'],\n   *     onOverflow: {\n   *       left: 'forcepush',\n   *       right: 'push',\n   *       top: 'none',\n   *       bottom: 'push'\n   *     }\n   *   },\n   *   adjust: function (position, data) {\n   *     position.left -= 1;\n   *     position.top += 1;\n   *   }\n   * });\n   *\n   * @public\n   * @param {PlaceOptions} options\n   * @returns {PlaceData}\n   */\n  function getPlace(options) {\n\n    var ret = {};\n    var opts = mergeObjects([settings.placeDefaultOptions, options || {}]);\n    var position = typeof opts.position === 'string' ? opts.position.split(' ') : opts.position;\n    var eRect = getSanitizedRect(opts.element, true);\n    var tRect = getSanitizedRect(opts.target);\n    var isContainDefined = isPlainObject(opts.contain);\n    var container = isContainDefined && opts.contain.within;\n    var overflowAction = isContainDefined && getOverflowAction(opts.contain.onOverflow);\n    var overflowFixLeft = 0;\n    var overflowFixTop = 0;\n    var offsetX = opts.offsetX;\n    var offsetY = opts.offsetY;\n    var cRect;\n    var overlap;\n    var eCurrentOffset;\n\n    // Sanitize offsets and check for percentage values.\n    offsetX = typeof offsetX === 'string' && offsetX.indexOf('%') > -1 ? toFloat(offsetX) / 100 * eRect.width : toFloat(offsetX);\n    offsetY = typeof offsetY === 'string' && offsetY.indexOf('%') > -1 ? toFloat(offsetY) / 100 * eRect.height : toFloat(offsetY);\n\n    // Calculate element's new position (left/top coordinates).\n    ret.left = getPlacePosition(position[0], position[2], tRect.width, tRect.left, eRect.width, eRect.left, offsetX);\n    ret.top = getPlacePosition(position[1], position[3], tRect.height, tRect.top, eRect.height, eRect.top, offsetY);\n\n    // Update element offset data to match the newly calculated position.\n    eRect.left += ret.left;\n    eRect.top += ret.top;\n\n    // If container element and overflow action are defined, let's handle\n    // container's possible overflow.\n    if (container && overflowAction) {\n\n      // Get container rect and overlap data.\n      cRect = getSanitizedRect(container);\n      overlap = getOverlap(eRect, cRect);\n\n      // Handle horizontal overflow.\n      if (overlap.left < 0 || overlap.right < 0) {\n        overflowFixLeft = getPlaceOverflowPush(overflowAction, overlap);\n        ret.left += overflowFixLeft;\n      }\n\n      // Handle vertical overflow.\n      if (overlap.top < 0 || overlap.bottom < 0) {\n        overflowFixTop = getPlaceOverflowPush(overflowAction, overlap, 1);\n        ret.top += overflowFixTop;\n      }\n\n    }\n\n    if (typeof opts.adjust === 'function') {\n\n      // Update element's left and right rect data to account for the possible\n      // overflow correction.\n      if (overflowFixLeft !== 0) {\n        eRect.left += overflowFixLeft;\n        eRect.right = eRect.left + eRect.width;\n      }\n\n      // Update element's top and bottom rect data to account for the possible\n      // overflow correction.\n      if (overflowFixTop !== 0) {\n        eRect.top += overflowFixTop;\n        eRect.bottom = eRect.left + eRect.width;\n      }\n\n      // Get container rect.\n      cRect = container ? cRect || getSanitizedRect(container) : null;\n\n      // Get the element's current offset so we can calculate how much the\n      // element moved.\n      eCurrentOffset = isPlainObject(opts.element) ? opts.element : getOffsetFromDocument.apply(null, [].concat(opts.element));\n\n      // Calculate overlap data based on the new position.\n      overlap = cRect ? getOverlap(eRect, cRect) : null;\n\n      // Provide the final position hash as the first argument (which can be\n      // modified and it affects the return value of this method) and all the\n      // positioning data as the second argument.\n      opts.adjust(ret, {\n        elementRect: eRect,\n        targetRect: tRect,\n        containerRect: cRect,\n        shift: {\n          left: eRect.left - eCurrentOffset.left,\n          top: eRect.top - eCurrentOffset.top\n        },\n        overflow: !overlap ? null : {\n          left: -overlap.left,\n          right: -overlap.right,\n          top: -overlap.top,\n          bottom: -overlap.bottom\n        },\n        overflowCorrection: {\n          left: overflowFixLeft,\n          top: overflowFixTop\n        }\n      });\n\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Private helper functions\n   * ************************\n   */\n\n  /**\n   * Check if a value is a plain object.\n   *\n   * @private\n   * @param {*} val\n   * @returns {Boolean}\n   */\n  function isPlainObject(val) {\n\n    return typeof val === 'object' && Object.prototype.toString.call(val) === '[object Object]';\n\n  }\n\n  /**\n   * Returns the supported transform property's prefix, property name and style\n   * name or null if transforms are not supported.\n   *\n   * @private\n   * @returns {?Object}\n   */\n  function getSupportedTransform() {\n\n    var transforms = ['transform', 'WebkitTransform', 'MozTransform', 'OTransform', 'msTransform'];\n\n    for (var i = 0; i < transforms.length; i++) {\n      if (root.style[transforms[i]] !== undefined) {\n\n        var prop = transforms[i];\n        var prefix = prop.toLowerCase().split('transform')[0];\n\n        return {\n          prefix: prefix,\n          propName: prop,\n          styleName: prefix ? '-' + prefix + '-transform' : prop\n        };\n\n      }\n    }\n\n    return null;\n\n  }\n\n  /**\n   * Detects if transformed elements leak fixed elements. According W3C\n   * transform rendering spec a transformed element should contain even fixed\n   * elements. Meaning that fixed elements are positioned relative to the\n   * closest transformed ancestor element instead of window. However, not every\n   * browser follows the spec (IE and older Firefox), so we need to test it.\n   * https://www.w3.org/TR/css3-2d-transforms/#transform-rendering\n   *\n   * @private\n   * @returns {Boolean}\n   *   - Returns true if transformed elements leak fixed elements, false\n   *     otherwise.\n   */\n  function doesTransformLeakFixed() {\n\n    if (!settings.transform) {\n      return true;\n    }\n\n    var outer = doc.createElement('div');\n    var inner = doc.createElement('div');\n    var leftNotTransformed;\n    var leftTransformed;\n\n    setStyles(outer, {\n      display: 'block',\n      visibility: 'hidden',\n      position: 'absolute',\n      width: '1px',\n      height: '1px',\n      left: '1px',\n      top: '0',\n      margin: '0'\n    });\n\n    setStyles(inner, {\n      display: 'block',\n      position: 'fixed',\n      width: '1px',\n      height: '1px',\n      left: '0',\n      top: '0',\n      margin: '0'\n    });\n\n    outer.appendChild(inner);\n    body.appendChild(outer);\n    leftNotTransformed = inner.getBoundingClientRect().left;\n    outer.style[settings.transform.propName] = 'translateX(0)';\n    leftTransformed = inner.getBoundingClientRect().left;\n    body.removeChild(outer);\n\n    return leftTransformed === leftNotTransformed;\n\n  }\n\n  /**\n   * Returns true if element is transformed, false if not. In practice the\n   * element's display value must be anything else than \"none\" or \"inline\" as\n   * well as have a valid transform value applied in order to be counted as a\n   * transformed element.\n   *\n   * @private\n   * @param {Element} el\n   * @returns {Boolean}\n   */\n  function isTransformed(el) {\n\n    var transform = getStyle(el, settings.transform.styleName);\n    var display = getStyle(el, 'display');\n\n    return transform !== 'none' && display !== 'inline' && display !== 'none';\n\n  }\n\n  /**\n   * Customized parseFloat function which returns 0 instead of NaN.\n   *\n   * @private\n   * @param {Number|String} val\n   * @returns {Number}\n   */\n  function toFloat(val) {\n\n    return parseFloat(val) || 0;\n\n  }\n\n  /**\n   * Deep merge an array of objects into a new object.\n   *\n   * @private\n   * @param {Array} array\n   * @returns {Object}\n   */\n  function mergeObjects(array) {\n\n    var ret = {};\n    var propName;\n    var propVal;\n\n    for (var i = 0, len = array.length; i < len; i++) {\n      for (propName in array[i]) {\n        if (array[i].hasOwnProperty(propName)) {\n          propVal = array[i][propName];\n          ret[propName] = isPlainObject(propVal) ? mergeObjects([propVal]) :\n                          Array.isArray(propVal) ? propVal.slice() :\n                                                   propVal;\n        }\n      }\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Returns the computed value of an element's style property as a string.\n   *\n   * @private\n   * @param {Element} el\n   * @param {String} style\n   * @returns {String}\n   */\n  function getStyle(el, style) {\n\n    return win.getComputedStyle(el, null).getPropertyValue(style);\n\n  }\n\n  /**\n   * Returns the computed value of an element's style property transformed into\n   * a float value.\n   *\n   * @private\n   * @param {Element} el\n   * @param {String} style\n   * @returns {Number}\n   */\n  function getStyleAsFloat(el, style) {\n\n    return toFloat(getStyle(el, style));\n\n  }\n\n  /**\n   * Set inline styles to an element.\n   *\n   * @private\n   * @param {Element} el\n   * @param {Object} styles\n   */\n  function setStyles(el, styles) {\n\n    Object.keys(styles).forEach(function (styleName) {\n      el.style[styleName] = styles[styleName];\n    });\n\n  }\n\n  /**\n   * Calculates how much element overlaps another element from each side.\n   *\n   * @private\n   * @param {(Array|Document|Element|Window|Rectangle)} elA\n   * @param {(Array|Document|Element|Window|Rectangle)} elB\n   * @returns {Overlap}\n   */\n  function getOverlap(elA, elB) {\n\n    var aRect = getSanitizedRect(elA);\n    var bRect = getSanitizedRect(elB);\n\n    return {\n      left: aRect.left - bRect.left,\n      right: (bRect.left + bRect.width) - (aRect.left + aRect.width),\n      top: aRect.top - bRect.top,\n      bottom: (bRect.top + bRect.height) - (aRect.top + aRect.height)\n    };\n\n  }\n\n  /**\n   * Detect if two elements overlap and calculate the possible intersection\n   * area's dimensions and offsets. If the intersection area exists the function\n   * returns an object containing the intersection area's dimensions and\n   * offsets. Otherwise null is returned.\n   *\n   * @private\n   * @param {(Array|Document|Element|Window|Rectangle)} elA\n   * @param {(Array|Document|Element|Window|Rectangle)} elB\n   * @returns {?RectangleExtended}\n   */\n  function getIntersection(elA, elB) {\n\n    var ret = {};\n    var aRect = getSanitizedRect(elA);\n    var bRect = getSanitizedRect(elB);\n    var overlap = getOverlap(aRect, bRect);\n    var intWidth = max(aRect.width + min(overlap.left, 0) + min(overlap.right, 0), 0);\n    var intHeight = max(aRect.height + min(overlap.top, 0) + min(overlap.bottom, 0), 0);\n    var hasIntersection = intWidth > 0 && intHeight > 0;\n\n    if (hasIntersection) {\n      ret.width = intWidth;\n      ret.height = intHeight;\n      ret.left = aRect.left + abs(min(overlap.left, 0));\n      ret.top = aRect.top + abs(min(overlap.top, 0));\n      ret.right = ret.left + ret.width;\n      ret.bottom = ret.top + ret.height;\n    }\n\n    return hasIntersection ? ret : null;\n\n  }\n\n  /**\n   * Calculates the distance between two points in 2D space.\n   *\n   * @private\n   * @param {Number} aLeft\n   * @param {Number} aTop\n   * @param {Number} bLeft\n   * @param {Number} bTop\n   * @returns {Number}\n   */\n  function getDistanceBetweenPoints(aLeft, aTop, bLeft, bTop) {\n\n    return Math.sqrt(Math.pow(bLeft - aLeft, 2) + Math.pow(bTop - aTop, 2));\n\n  }\n\n  /**\n   * Calculates the distance between two unrotated rectangles in 2D space. This\n   * function assumes that the rectangles do not intersect.\n   *\n   * @private\n   * @param {Rectangle} rectA\n   * @param {Rectangle} rectB\n   * @returns {Number}\n   */\n  function getDistanceBetweenRects(rectA, rectB) {\n\n    var ret = 0;\n    var aLeft = rectA.left;\n    var aRight = aLeft + rectA.width;\n    var aTop = rectA.top;\n    var aBottom = aTop + rectA.height;\n    var bLeft = rectB.left;\n    var bRight = bLeft + rectB.width;\n    var bTop = rectB.top;\n    var bBottom = bTop + rectB.height;\n\n    // Calculate shortest corner distance\n    if ((bLeft > aRight || bRight < aLeft) && (bTop > aBottom || bBottom < aTop)) {\n      if (bLeft > aRight) {\n        ret = bBottom < aTop ? getDistanceBetweenPoints(aRight, aTop, bLeft, bBottom) : getDistanceBetweenPoints(aRight, aBottom, bLeft, bTop);\n      }\n      else {\n        ret = bBottom < aTop ? getDistanceBetweenPoints(aLeft, aTop, bRight, bBottom) : getDistanceBetweenPoints(aLeft, aBottom, bRight, bTop);\n      }\n    }\n\n    // Calculate shortest edge distance\n    else {\n      ret = bBottom < aTop ? aTop - bBottom :\n            bLeft > aRight ? bLeft - aRight :\n            bTop > aBottom ? bTop - aBottom :\n            aLeft - bRight;\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Returns the height/width of an element in pixels. The function also accepts\n   * the window object (for obtaining the viewport dimensions) and the document\n   * object (for obtaining the dimensions of the document) in place of element.\n   * Note that this function considers root element's scrollbars as the\n   * document's and window's scrollbars also. Since the root element's\n   * scrollbars are always stuck on the right/bottom edge of the window (even if\n   * you specify width and/or height to root element) they are generally\n   * referred to as viewport scrollbars in the docs. Also note that only\n   * positive margins are included in the result when includeMargin argument is\n   * true.\n   *\n   * @private\n   * @param {String} dimension\n   *   - Accepts \"width\" or \"height\".\n   * @param {(Document|Element|Window)} el\n   * @param {Boolean} [includePadding=false]\n   * @param {Boolean} [includeScrollbar=false]\n   * @param {Boolean} [includeBorder=false]\n   * @param {Boolean} [includeMargin=false]\n   * @returns {Number}\n   *   - The return value may be fractional when calculating the width of an\n   *     element. For window and document objects the value is always an integer\n   *     though.\n   */\n  function getDimension(dimension, el, includePadding, includeScrollbar, includeBorder, includeMargin) {\n\n    var ret;\n    var isHeight = dimension === 'height';\n    var dimensionCapitalized = isHeight ? 'Height' : 'Width';\n    var innerDimension = 'inner' + dimensionCapitalized;\n    var clientDimension = 'client' + dimensionCapitalized;\n    var scrollDimension = 'scroll' + dimensionCapitalized;\n    var sbSize = 0;\n    var edgeA;\n    var edgeB;\n    var borderA;\n    var borderB;\n    var marginA;\n    var marginB;\n\n    if (el.self === win.self) {\n\n      ret = includeScrollbar ? win[innerDimension] : root[clientDimension];\n\n    }\n    else if (el === doc) {\n\n      if (includeScrollbar) {\n        sbSize = win[innerDimension] - root[clientDimension];\n        ret = max(root[scrollDimension] + sbSize, body[scrollDimension] + sbSize, win[innerDimension]);\n      }\n      else {\n        ret = max(root[scrollDimension], body[scrollDimension], root[clientDimension]);\n      }\n\n    }\n    else {\n\n      edgeA = isHeight ? 'top' : 'left';\n      edgeB = isHeight ? 'bottom' : 'right';\n      ret = (tempBCR || el.getBoundingClientRect())[dimension];\n\n      if (!includeScrollbar) {\n\n        if (el === root) {\n          sbSize = win[innerDimension] - root[clientDimension];\n        }\n        else if (unscrollableDisplayValues.indexOf(getStyle(el, 'display')) < 0) {\n          borderA = getStyleAsFloat(el, 'border-' + edgeA + '-width');\n          borderB = getStyleAsFloat(el, 'border-' + edgeB + '-width');\n          sbSize = Math.round(ret) - (el[clientDimension] + borderA + borderB);\n        }\n\n        ret -= sbSize > 0 ? sbSize : 0;\n\n      }\n\n      if (!includePadding) {\n        ret -= getStyleAsFloat(el, 'padding-' + edgeA);\n        ret -= getStyleAsFloat(el, 'padding-' + edgeB);\n      }\n\n      if (!includeBorder) {\n        ret -= borderA !== undefined ? borderA : getStyleAsFloat(el, 'border-' + edgeA + '-width');\n        ret -= borderB !== undefined ? borderB : getStyleAsFloat(el, 'border-' + edgeB + '-width');\n      }\n\n      if (includeMargin) {\n        marginA = getStyleAsFloat(el, 'margin-' + edgeA);\n        marginB = getStyleAsFloat(el, 'margin-' + edgeB);\n        ret += marginA > 0 ? marginA : 0;\n        ret += marginB > 0 ? marginB : 0;\n      }\n\n    }\n\n    return ret > 0 ? ret : 0;\n\n  }\n\n  /**\n   * Returns the element's (or window's) document offset, which in practice\n   * means the vertical and horizontal distance between the element's northwest\n   * corner and the document's northwest corner.\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} [edge='border']\n   * @returns {Offset}\n   */\n  function getOffsetFromDocument(el, edge) {\n\n    var ret = {\n      left: 0,\n      top: 0\n    };\n\n    // Document's offsets are always 0.\n    if (el === doc) {\n      return ret;\n    }\n\n    // Add viewport's scroll left/top to the respective offsets.\n    ret.left = win.pageXOffset || 0;\n    ret.top = win.pageYOffset || 0;\n\n    // Window's offsets are the viewport's scroll left/top values.\n    if (el.self === win.self) {\n      return ret;\n    }\n\n    // Now we know we are calculating an element's offsets so let's first get\n    // the element's bounding client rect. If it is not cached, then just fetch\n    // it.\n    var gbcr = tempBCR || el.getBoundingClientRect();\n\n    // Add bounding client rect's left/top values to the offsets.\n    ret.left += gbcr.left;\n    ret.top += gbcr.top;\n\n    // Sanitize edge.\n    edge = edge && edges[edge] || 4;\n\n    // Exclude element's positive margin size from the offset if needed.\n    if (edge === 5) {\n      var marginLeft = getStyleAsFloat(el, 'margin-left');\n      var marginTop = getStyleAsFloat(el, 'margin-top');\n      ret.left -= marginLeft > 0 ? marginLeft : 0;\n      ret.top -= marginTop > 0 ? marginTop : 0;\n    }\n\n    // Include element's border size to the offset if needed.\n    if (edge < 4) {\n      ret.left += getStyleAsFloat(el, 'border-left-width');\n      ret.top += getStyleAsFloat(el, 'border-top-width');\n    }\n\n    // Include element's padding size to the offset if needed.\n    if (edge === 1) {\n      ret.left += getStyleAsFloat(el, 'padding-left');\n      ret.top += getStyleAsFloat(el, 'padding-top');\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Returns an object containing the provided element's dimensions and offsets.\n   * This is basically just a wrapper for the getRectInternal function which\n   * does some argument normalization before doing the actal calculations. Used\n   * only internally.\n   *\n   * @private\n   * @param {(Array|Document|Element|Window|Rectangle)} el\n   * @param {Boolean} [useStaticOffset=false]\n   * @returns {?Rectangle}\n   */\n  function getSanitizedRect(el, useStaticOffset) {\n\n    // Can't have an empty value.\n    if (!el) {\n      return null;\n    }\n\n    // Let's assume that plain objects are static rectangle definitions.\n    if (isPlainObject(el)) {\n      return el;\n    }\n\n    // We don't know for sure if the provided element is defined with an edge\n    // layer (array syntax) or not. So let's play it safe an normalize the value\n    // to an array.\n    el = [].concat(el);\n\n    return getRectInternal(el[0], el[1], useStaticOffset);\n\n  }\n\n  /**\n   * Returns an object containing the provided element's dimensions and offsets.\n   * This is basically a helper method for calculating an element's dimensions\n   * and offsets simultaneously. Mimics the native getBoundingClientRect method\n   * with the added bonus of allowing to provide the \"edge\" of the element.\n   *\n   * @public\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} [edge='border']\n   * @param {Boolean} [useStaticOffset=false]\n   * @returns {Rectangle}\n   */\n  function getRectInternal(el, edge, useStaticOffset) {\n\n    var isElem = el !== doc && el.self !== win.self;\n    var rect;\n\n    // Sanitize edge.\n    edge = edge || 'border';\n\n    // If static offset is required we have to get it before temporary bounding\n    // client rect is cached, since it might need to get the offset of another\n    // element than the cached one.\n    if (useStaticOffset) {\n      rect = getStaticOffset(el, edge);\n    }\n\n    // Cache element's bounding client rect.\n    if (isElem) {\n      tempBCR = el.getBoundingClientRect();\n    }\n\n    // If static offset is not required we know for sure that the temporary\n    // bounding client rect is the same element we need to get offset for.\n    if (!useStaticOffset) {\n      rect = getOffsetFromDocument(el, edge);\n    }\n\n    // Get element's width and height.\n    rect.width = getWidth(el, edge);\n    rect.height = getHeight(el, edge);\n\n    // Calculate element's bottom and right.\n    rect.bottom = rect.top + rect.height;\n    rect.right = rect.left + rect.width;\n\n    // Nullify temporary bounding client rect cache.\n    if (isElem) {\n      tempBCR = null;\n    }\n\n    return rect;\n\n  }\n\n  /**\n   * Returns an element's static offset which in this case means the element's\n   * offset in a state where the element's left and top CSS properties are set\n   * to 0.\n   *\n   * @private\n   * @param {(Document|Element|Window)} el\n   * @param {Edge} edge\n   * @returns {Offset}\n   */\n  function getStaticOffset(el, edge) {\n\n    // Sanitize edge.\n    edge = edge || 'border';\n\n    // For window and document just return normal offset.\n    if (el === win || el === doc) {\n      return getOffsetFromDocument(el, edge);\n    }\n\n    var position = getStyle(el, 'position');\n    var offset = position === 'absolute' || position === 'fixed' ? getOffsetFromDocument(getContainingBlock(el) || doc, 'padding') : getOffsetFromDocument(el, edge);\n\n    if (position === 'relative') {\n\n      var left = getStyle(el, 'left');\n      var right = getStyle(el, 'right');\n      var top = getStyle(el, 'top');\n      var bottom = getStyle(el, 'bottom');\n\n      if (left !== 'auto' || right !== 'auto') {\n        offset.left -= left === 'auto' ? -toFloat(right) : toFloat(left);\n      }\n\n      if (top !== 'auto' || bottom !== 'auto') {\n        offset.top -= top === 'auto' ? -toFloat(bottom) : toFloat(top);\n      }\n\n    }\n    else if (position === 'absolute' || position === 'fixed') {\n\n      // Get edge number.\n      edge = edges[edge];\n\n      // Get left and top margins.\n      var marginLeft = getStyleAsFloat(el, 'margin-left');\n      var marginTop = getStyleAsFloat(el, 'margin-top');\n\n      // If edge is \"margin\" remove negative left/top margins from offset to\n      // account for their effect on position.\n      if (edge === 5) {\n        offset.left -= abs(min(marginLeft, 0));\n        offset.top -= abs(min(marginTop, 0));\n      }\n\n      // If edge is \"border\" or smaller add positive left/top margins and remove\n      // negative left/top margins from offset to account for their effect on\n      // position.\n      if (edge < 5) {\n        offset.left += marginLeft;\n        offset.top += marginTop;\n      }\n\n      // If edge is \"scroll\" or smaller add left/top borders to offset to\n      // account for their effect on position.\n      if (edge < 4) {\n        offset.left += getStyleAsFloat(el, 'border-left-width');\n        offset.top += getStyleAsFloat(el, 'border-top-width');\n      }\n\n      // If edge is \"content\" add left/top paddings to offset to account for\n      // their effect on position.\n      if (edge === 1) {\n        offset.left += getStyleAsFloat(el, 'padding-left');\n        offset.top += getStyleAsFloat(el, 'padding-top');\n      }\n\n    }\n\n    return offset;\n\n  }\n\n  /**\n   * Returns the horizontal or vertical base position of an element relative to\n   * the target element. In other words, this function returns the left and top\n   * CSS values which should be set as to the target element in order to\n   * position it according to the desired position.\n   *\n   * @private\n   * @param {String} elementPosition\n   *   - Element's position: \"left\", \"right\", \"top\", \"bottom\" or \"center\".\n   * @param {String} targetPosition\n   *   - Target's position: \"left\", \"right\", \"top\", \"bottom\" or \"center\".\n   * @param {Number} targetSize\n   *   - Target's width/height in pixels.\n   * @param {Number} targetOffset\n   *   - Target's left/top offset in pixels.\n   * @param {Number} elementSize\n   *   - Element's width/height in pixels.\n   * @param {Number} elementNwOffset\n   *   - Element's left/top northwest offset in pixels.\n   * @param {Number} extraOffset\n   *   - Additional left/top offset in pixels.\n   * @returns {Number}\n   */\n  function getPlacePosition(elementPosition, targetPosition, targetSize, targetOffset, elementSize, elementNwOffset, extraOffset) {\n\n    var placement = elementPosition.charAt(0) + targetPosition.charAt(0);\n    var northwestPoint = targetOffset + extraOffset - elementNwOffset;\n\n    return placement === 'll' || placement === 'tt' ? northwestPoint :\n           placement === 'lc' || placement === 'tc' ? northwestPoint + (targetSize / 2) :\n           placement === 'lr' || placement === 'tb' ? northwestPoint + targetSize :\n           placement === 'cl' || placement === 'ct' ? northwestPoint - (elementSize / 2) :\n           placement === 'cr' || placement === 'cb' ? northwestPoint + targetSize - (elementSize / 2) :\n           placement === 'rl' || placement === 'bt' ? northwestPoint - elementSize :\n           placement === 'rc' || placement === 'bc' ? northwestPoint - elementSize + (targetSize / 2) :\n           placement === 'rr' || placement === 'bb' ? northwestPoint - elementSize + targetSize :\n                                                      northwestPoint + (targetSize / 2) - (elementSize / 2);\n\n  }\n\n  /**\n   * Calculates the distance in pixels that the element needs to be moved in\n   * order to be aligned correctly if the target element overlaps the container.\n   *\n   * @private\n   * @param {OverflowConfig} overflowConfig\n   * @param {Overlap} targetOverlap\n   * @param {Boolean} isVertical\n   * @returns {Number}\n   */\n  function getPlaceOverflowPush(overflowConfig, targetOverlap, isVertical) {\n\n    var ret = 0;\n    var push = 'push';\n    var forcePush = 'forcepush';\n    var sideA = isVertical ? 'top' : 'left';\n    var sideB = isVertical ? 'bottom' : 'right';\n    var sideAConfig = overflowConfig[sideA];\n    var sideBConfig = overflowConfig[sideB];\n    var sideAOverlap = targetOverlap[sideA];\n    var sideBOverlap = targetOverlap[sideB];\n    var sizeDifference = sideAOverlap + sideBOverlap;\n\n    // If pushing is needed from both sides.\n    if ((sideAConfig === push || sideAConfig === forcePush) && (sideBConfig === push || sideBConfig === forcePush) && (sideAOverlap < 0 || sideBOverlap < 0)) {\n\n      // Do push correction from opposite sides with equal force.\n      if (sideAOverlap < sideBOverlap) {\n        ret -= sizeDifference < 0 ? sideAOverlap + abs(sizeDifference / 2) : sideAOverlap;\n      }\n\n      // Do push correction from opposite sides with equal force.\n      if (sideBOverlap < sideAOverlap) {\n        ret += sizeDifference < 0 ? sideBOverlap + abs(sizeDifference / 2) : sideBOverlap;\n      }\n\n      // Update overlap data.\n      sideAOverlap += ret;\n      sideBOverlap -= ret;\n\n      // Check if left/top side forced push correction is needed.\n      if (sideAConfig === forcePush && sideBConfig !== forcePush && sideAOverlap < 0) {\n        ret -= sideAOverlap;\n      }\n\n      // Check if right/top side forced push correction is needed.\n      if (sideBConfig === forcePush && sideAConfig !== forcePush && sideBOverlap < 0) {\n        ret += sideBOverlap;\n      }\n\n    }\n\n    // Check if pushing is needed from left or top side only.\n    else if ((sideAConfig === forcePush || sideAConfig === push) && sideAOverlap < 0) {\n      ret -= sideAOverlap;\n    }\n\n    // Check if pushing is needed from right or bottom side only.\n    else if ((sideBConfig === forcePush || sideBConfig === push) && sideBOverlap < 0) {\n      ret += sideBOverlap;\n    }\n\n    return ret;\n\n  }\n\n  /**\n   * Sanitize contain.onOverflow option of .place() method.\n   *\n   * @private\n   * @param {OverflowConfig} overflowConfig\n   * @returns {?overflowConfigSanitized}\n   */\n  function getOverflowAction(overflowConfig) {\n\n    var actionType = typeof overflowConfig;\n    var left = 'none';\n    var right = 'none';\n    var top = 'none';\n    var bottom = 'none';\n\n    // onOverflow string value is always used for all sides.\n    if (actionType === 'string') {\n      left = right = top = bottom = overflowConfig;\n    }\n\n    // onOverflow object value can have properties that present a side\n    // (left/right/top/bottom) or an axis (x/y). Always try to use the side\n    // value first and then fallback to axis value. If all else fails fallback\n    // to \"none\".\n    else if (actionType === 'object') {\n      left = overflowConfig.left || overflowConfig.x || left;\n      right = overflowConfig.right || overflowConfig.x || right;\n      top = overflowConfig.top || overflowConfig.y || top;\n      bottom = overflowConfig.bottom || overflowConfig.y || bottom;\n    }\n\n    // If one side (or more) has a value other than \"none\" we know that the\n    // contain option might have an effect on the positioning.\n    if (left !== 'none' || right !== 'none' || top !== 'none' || bottom !== 'none') {\n      return {\n        left: left,\n        right: right,\n        top: top,\n        bottom: bottom\n      };\n    }\n\n    return null;\n\n  }\n\n  /**\n   * Custom type definitions\n   * ***********************\n   */\n\n  /**\n   * The browser's window object.\n   *\n   * @typedef {Object} Window\n   */\n\n  /**\n   * The document contained in browser's window object.\n   *\n   * @typedef {Object} Document\n   */\n\n  /**\n   * Any HTML element including root and body elements.\n   *\n   * @typedef {Object} Element\n   */\n\n  /**\n   * The name of an element's box model edge which allows you to decide which\n   * areas of the element you want to include in the calculations. Valid edge\n   * values are \"content\", \"padding\", \"scroll\", \"border\" and \"margin\", in that\n   * specific order. Note that \"scroll\" is not a valid element edge accroding to\n   * W3C spec, but it is used here to define whether or not the scrollbar's size\n   * should be included in the calculations. For window and document objects\n   * this argument behaves a bit differently since they cannot have any\n   * paddings, borders or margins. Only \"content\" (without vertical scrollbar’s\n   * width) and \"scroll\" (with vertical scrollbar’s width) are effective values.\n   * \"padding\" is normalized to \"content\" while \"border\" and \"margin\" are\n   * normalized to \"scroll\".\n   *\n   * @typedef {String} Edge\n   */\n\n  /**\n   * @typedef {Object} Rectangle\n   * @property {Number} left\n   *   - Element's horizontal distance from the left edge of the document.\n   * @property {Number} top\n   *   - Element's vertical distance from the top edge of the document.\n   * @property {Number} height\n   *   - Element's height.\n   * @property {Number} width\n   *   - Element's width.\n   */\n\n  /**\n   * @typedef {Object} RectangleExtended\n   * @property {Number} left\n   *   - Element's horizontal distance from the left edge of the document.\n   * @property {Number} right\n   *   - Element's horizontal distance from the left edge of the document plus\n   *     width.\n   * @property {Number} top\n   *   - Element's vertical distance from the top edge of the document\n   * @property {Number} bottom\n   *   - Element's vertical distance from the top edge of the document plus\n   *     height.\n   * @property {Number} height\n   *   - Element's height.\n   * @property {Number} width\n   *   - Element's width.\n   */\n\n  /**\n   * @typedef {Object} Offset\n   * @property {Number} left\n   *   - Element's horizontal distance from the left edge of the document,\n   *     window or other element.\n   * @property {Number} top\n   *   - Element's vertical distance from the top edge of the document, window,\n   *     or other element.\n   */\n\n  /**\n   * @typedef {Object} Overlap\n   * @property {Number} left\n   * @property {Number} top\n   * @property {Number} right\n   * @property {Number} bottom\n   */\n\n  /**\n   * @typedef {Object} Overflow\n   * @property {Number} left\n   * @property {Number} top\n   * @property {Number} right\n   * @property {Number} bottom\n   */\n\n  /**\n   * @typedef {Object} PlaceOptions\n   * @param {(Array|Document|Element|Window|Rectangle)} element\n   * @property {(Array|Document|Element|Window|Rectangle)} target\n   * @property {PlaceOptionsPosition} [position='left top left top']\n   * @property {Number} [offsetX=0]\n   * @property {Number} [offsetY=0]\n   * @property {?PlaceOptionsContainment} [contain=null]\n   */\n\n  /**\n   * Raw positioning data for position option of .place() method.\n   * String syntax: \"elemX elemY targetX targetY\".\n   * Array syntax: [\"elemX\", \"elemY\", \"targetX\", \"targetY\"].\n   * Possible values for elemX and targetX: \"left\", \"center\", \"right\".\n   * Possible values for elemY and targetY: \"top\", \"center\", \"bottom\".\n   *\n   * @typedef {(Array|String)} PlaceOptionsPosition\n   */\n\n  /**\n   * All properties accepts the following values: \"push\", \"forcepush\" and\n   * \"none\".\n   *\n   * @typedef {Object} PlaceOptionsContainment\n   * @property {?(Array|Document|Element|Window|Rectangle)} within\n   * @property {?(OverflowConfig|String)} onOverflow\n   */\n\n  /**\n   * All properties accepts the following values: \"push\", \"forcepush\" and\n   * \"none\". The properties left, right, top and bottom are used to define the\n   * overflow action that should be called when the positioned element overflows\n   * the container element from the respective side. Alternatively you can also\n   * use the properties x and y to define the overflow action per axis. If you\n   * mix side overflow properties with axis overflow properties remember that\n   * the side configuration overwrites the axis configuration.\n   *\n   * @typedef {Object} OverflowConfig\n   * @property {String} [left='none']\n   * @property {String} [right='none']\n   * @property {String} [top='none']\n   * @property {String} [bottom='none']\n   * @property {String} [x='none']\n   * @property {String} [y='none']\n   */\n\n  /**\n   * A sanitized configuration data object for contain.onOverflow option of\n   * .place() method.\n   *\n   * @typedef {Object} OverflowConfigSanitized\n   * @property {String} left\n   * @property {String} right\n   * @property {String} top\n   * @property {String} bottom\n   */\n\n  /**\n   * @typedef {Object} PlaceData\n   * @property {Number} left\n   *   - Target element's new left position.\n   * @property {Number} top\n   *   - Target element's new top position.\n   */\n\n  // Name and return the public methods.\n  return {\n    width: getWidth,\n    height: getHeight,\n    offset: getOffset,\n    rect: getRect,\n    containingBlock: getContainingBlock,\n    distance: getDistance,\n    intersection: getIntersectionMultiple,\n    overflow: getOverflow,\n    place: getPlace,\n    _settings: settings\n  };\n\n}));\n"],"sourceRoot":""}